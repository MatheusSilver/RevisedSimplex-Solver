class LanguageDictionary:
    PORTUGUESE_DICTIONARY = {
        "pt": "Português Brasileiro",
        "en": "Inglês",
        "es": "Espanhol",
        "return_to_main_menu": "Voltar ao menu principal",
        "solve_one": "Resolver um problema de Otimização Linear",
        "solve_all": "Resolver todos os problemas de Otimização Linear disponíveis",
        "no_files": "Nenhum arquivo disponível para resolver.",
        "directory_not_exists": "O diretório especificado não existe.",
        "no_file_error": "Erro: Nenhum arquivo foi encontrado.",
        "select_file_intro": "Por favor, selecione o arquivo que deseja resolver: ",
        "conv_all_confirmation": "Foram encontrados <x1> arquivos, tem certeza que deseja escrever todos no documento LaTeX? (s/n): ",
        "exercise_solved": "O problema <x1> foi resolvido e escrito no documento LaTeX com sucesso.",
        "all_exercises_solved": "Todos os problemas foram resolvidos e escritos no documento LaTeX. \nDeseja encerrar o programa? (s/n): ",
        "select_file_options": "Digite o número correspondente ao arquivo: ",
        "show_steps": "Deseja visualizar os passos da resolução? (s/n): ",
        "exit_text": "Finalizando a aplicação...",
        "exit_state": "Encerrar o programa.",
        "main_menu": "Selecione uma opção",
        "number_to_do": "Escolha o número correspondente ao que deseja fazer: ",
        "language_menu": "Escolha um idioma",
        "language_options": "Escolha o número correspondente ao idioma: ",
        "invalid_state": "Não é um menu válido.",
        "invalid_choice": "Escolha inválida. Por favor, selecione um número entre 1 e",
        "invalid_option_error": "Erro: Entrada inválida. Por favor, insira um número válido.",

        "exercise_text": "Exercício: <x1>",
        "initial_problem_description": "O problema de otimização linear pode ser descrito pelas seguintes matrizes e vetores:",
        "restriction_matrix_text": "Matriz de restrições",
        "cost_vector_text": "Vetor de custo",
        "restriction_vector_text": "Vetor de restrições",
        "cost_change_max_text": "Considerando termos um problema de maximização, multiplicamos o vetor de custos por $-1$, obtendo:",
        "phase_one_text": "Fase 1",
        "phase_two_text": "Fase 2",
        "artificial_variables_removal": "Antes de continuar, precisamos nos livrar das variáveis artificiais, e para isso, resolvemos o problema auxiliar de forma a obter uma base sem as variáveis artificiais.",
        "artificial_variables_cost": "Com esse objetivo, iremos assumir temporariamente que o custo de todas as variáveis artificiais serão iguais a 1, ao passo que as não artificiais terão custo 0.",
        "initial_basic_non_basic_definition": "Começamos definindo nossas variáveis básicas e não básicas por $x_b$ e $x_n$, seguindo a lógica de:",
        "artificial_basis_definition": "Se a linha da matriz possui uma variável artificial adicionaremos ela ao conjunto de variáveis básicas, e a variável de folga correspondente, no conjunto das não básicas. \n\n Caso contrário, adicionaremos a variável de folga ao conjunto das variáveis básicas diretamente.",
        "following_bases_text": "Fazendo isso, encontramos as seguintes bases:",

        "infeasible/phase_1_text": "Ao finalizarmos o processo da fase 1, observamos que não foi possível remover as variáveis artificiais, com isso, como não há uma solução sem elas, podemos concluir que o problema é inviável.",
        "summarized/infeasible/phase_1_text": "It was not possible to remove the artificial variables, infeasible problem",

        "infeasible/phase_2_text": "A solução ótima encontrada possui valores negativos para as variáveis, com isto, podemos concluir que o problema é inviável.",
        "summarized/infeasible/phase_2_text": "Solução ótima possui valores negativos, problema inviável.",

        "phase_1_success_text": "Com isso, concluímos a fase 1, e obtemos a seguinte base inicial com os seguintes valores:",
        "phase_1_success_details": "Como conseguimos remover todas as variáveis artificiais da base, concluímos a fase 1 com exito.",
        "phase_1_next_step": "Agora, podemos aproveitar estes resultados e retornar ao problema original.",
        "phase_1_skip": "Como não passamos pela fase um, definimos nossas variáveis básicas como sendo as variáveis de folga.",
        "phase_2_direct": "E nossas variáveis não básicas como sendo as variáveis originais do problema, com tal definição, escrevemos:",
        "from_phase_1": "Como viemos da fase 1, assim como dito anteriormente, iremos utilizar do seguinte conjunto de variáveis básicas e não básicas, definidos por:",
        "max_text": "Máximo",
        "min_text": "Mínimo",
        "conclusion_text": "Conclusão",
        "optimal_solution_text": "Com isso, concluímos a fase 2, e obtemos a solução ótima abaixo:",
        "unbounded_solution_text": "Como vimos que na última iteração do Simplex, todos os valores de $y$ eram negativos ou nulos, concluímos que a variável não básica que entrará, poderá crescer indefinidamente, e portanto, teremos uma solução ilimitada.",
        "summarized_unbounded_text": "O problema é ilimitado",

        "numerical_solution_text": "Podemos calcular a solução correspondente ao <x1>, multiplicando os valores das variáveis, pelo vetor de custo, e obtemos que o resultado ótimo atingível do problema é <x1> = $<x2>$",
        "degenerate_solution": "Observe que a solução é degenerada, isto é, se tivéssemos tomado escolhas diferentes nas iterações <x1>, de forma a obtermos o mesmo resultado <x2>, mas com outro conjunto de variáveis básicas.",
        "maximum_iterations_exceeded_text": "Erro: Número máximo de iterações atingido.",
        "iteration_text": "Iteração <x1> (<x2>)",
        "current_status_text": "Estado atual do problema:",
        "step_1_text": "Passo 1: Cálculo do vetor básico ($x_b$)",
        "step_1_details": "Invertemos a matriz básica e multiplicamos pelo vetor de restrições:",
        "step_2_text": "Passo 2: Cálculo dos custos reduzidos ($c_r$)",
        "step_2_details": "O vetor de custos reduzidos é calculado como:",
        "step_3_text": "Passo 3: Escolha da variável que entra na base",
        "no_negative_pivot_found_details": "Como não temos nenhum candidato a entrar na base de forma a melhorar a solução, concluímos o processo.",
        "step_4_text": "Passo 4: Cálculo do vetor direção $y$",
        "step_4_details": "O vetor $y$ é calculado como:",
        "step_4_variable_details": "$A_n$ é o vetor coluna das restrições da variável que entrará na base.",
        "step_5_text": "Passo 5: Escolha da variável que sai da base",
        "step_5_details": r"Primeiro, calculamos as razões $\frac{x_b}{y}$, onde $y \geq 0$, caso contrário iremos considerar como infinito argumentando que ele certamente não será removido da base.",
        "step_5_formula_variable": "Razões",
        "phase_1_conclusion": "Conclusão da Fase 1",


        "get_negative_pivot_details": "A variável que entrará na base, é obtida ao procurarmos pelo elemento correspondente ao menor número negativo do vetor de custos reduzidos $c_r$.",
        "get_negative_pivot_entering_element_details": "Elemento a entrar na base $= min_{Negativo} <x1> $",
        "get_negative_pivot_element_index_text": "Com isso, escolhemos o elemento no índice <x1> da lista de variáveis não básicas $<x2>$ a partir do vetor de custos reduzidos $c_r$.",
        "get_negative_pivot_chosen_element_text": "Ou seja, concluímos que $<x1>$ entrará na base.",
        "get_negative_pivot_degeneracy": "Observe que aqui temos um ponto de degenerescência haja vista que podemos escolher outros elementos para entrar na base.",


        "get_positive_pivot_leaving_element_details": "Elemento a sair da base $= min_{Positivo} <x1> $",
        "get_positive_pivot_element_index_text": "Com isso, escolhemos o elemento no índice <x1> da lista de variáveis básicas $<x2>$ a partir do vetor coluna de razões.",
        "get_positive_pivot_chosen_element_text": "Ou seja, concluímos que $<x1>$ sairá da base.",
        "get_positive_pivot_degeneracy": "Observe que aqui temos um ponto de degenerescência haja vista que há outras opções igualmente benéficas para saírem da base.",

        "problem_standardization_text": "Padronização do Problema",
        "problem_standardization_details": "Para resolver o problema, precisamos primeiro escrevê-lo na forma padrão:",
        "problem_standardization_lt": "Para uma desigualdade do tipo $\leq$, adicionamos apenas uma variável de folga.",
        "problem_standardization_eq": "Para o caso de uma igualdade $=$, adicionamos apenas uma variável artificial.",
        "problem_standardization_gt": "Para o caso de uma desigualdade do tipo $\geq$, então subtraímos uma variável de folga e adicionamos uma variável artificial.",
        "problem_standardization_after": "Após a padronização, obteremos uma matriz de restrições no seguinte formato:",
        "problem_standardization_result": "E então, podemos escrever o problema na forma padrão como:",

        "maximize_text": "Maximizar",
        "minimize_text": "Minimizar",
        "subject_to_text": "Sujeito a",

        "optimal_solution_found": "Solução ótima encontrada!",
        "values_text": "Valores: ",
        "basic_variables_text": "Variáveis básicas: ",
        "simple_degenerate_text": "A solução é degenerada, isto é, pode haver mais do que um conjunto de variáveis básicas.",
        "solution_file_id": "solucao",
        "general_file_id": "geral"
    }

    ENGLISH_DICTIONARY = {
        "pt": "Brazilian Portuguese",
        "en": "English",
        "es": "Spanish",
        "return_to_main_menu": "Return to main menu",
        "solve_one": "Solve a Linear Optimization problem",
        "solve_all": "Solve all available Linear Optimization problems",
        "no_files": "No files available to solve.",
        "directory_not_exists": "The specified directory does not exist.",
        "no_file_error": "Error: No file was found.",
        "conv_all_confirmation": "<x1> files were found, are you sure you want to write them all in the LaTeX document? (y/n): ",
        "exercise_solved": "The <x1> problem has been solved and written to the LaTeX document successfully.",
        "all_exercises_solved": "All problems have been solved and written into the LaTeX document. \nDo you want to close the program? (y/n): ",
        "select_file_intro": "Please select the file you want to solve:",
        "select_file_options": "Enter the corresponding number for the file: ",
        "show_steps": "Do you want to view the solution steps? (y/n): ",
        "exit_text": "Closing the program...",
        "exit_state": "Exit the program.",
        "main_menu": "Select an option",
        "number_to_do": "Choose the number corresponding to what you want to do: ",
        "language_menu": "Choose a language",
        "language_options": "Choose the number corresponding to the language: ",
        "invalid_state": "This is not a valid menu.",
        "invalid_choice": "Invalid choice. Please select a number between 1 and",
        "invalid_option_error": "Error: Invalid input. Please enter a valid number.",

        "exercise_text": "Exercise: <x1>",
        "initial_problem_description": "The linear optimization problem can be described by the following matrices and vectors:",
        "restriction_matrix_text": "Constraint matrix",
        "cost_vector_text": "Cost vector",
        "restriction_vector_text": "Constraint vector",
        "cost_change_max_text": "Considering we have a maximization problem, we multiply the cost vector by $-1$, obtaining:",
        "phase_one_text": "Phase 1",
        "phase_two_text": "Phase 2",
        "artificial_variables_removal": "Before proceeding, we need to eliminate the artificial variables, and for this, we solve the auxiliary problem to obtain a basis without the artificial variables.",
        "artificial_variables_cost": "To this end, we will temporarily assume that the cost of all artificial variables will be equal to 1, while non-artificial variables will cost 0.",
        "initial_basic_non_basic_definition": "We start by defining our basic and non-basic variables as $x_b$ and $x_n$, following the logic:",
        "artificial_basis_definition": "If the matrix line has an artificial variable, we will add it to the set of basic variables, and the corresponding slack variable, to the set of non-basic variables. \n\n Otherwise, we will add the slack variable to the set of basic variables directly.",
        "following_bases_text": "Doing this, we find the following bases:",

        "infeasible/phase_1_text": "When we finished the phase 1 process, we observed that it was not possible to remove the artificial variables, therefore, as there is no solution without them, we can conclude that the problem is unfeasible.",
        "summarized/infeasible/phase_1_text": "Não foi possível remover as variáveis artificiais, problema inviável.",

        "infeasible/phase_2_text": "The optimal solution found has negative values for the variables, leading us to conclude that the problem is infeasible.",
        "summarized/infeasible/phase_2_text": "Optimal solution has negative values, unfeasible problem.",

        "phase_1_success_text": "Thus, we conclude Phase 1 and obtain the following initial basis values:",
        "phase_1_success_details": "As we managed to remove all artificial variables from the base, we completed phase 1 successfully.",
        "phase_1_next_step": "Now, we can take advantage of these results and return to the original problem.",
        "phase_1_skip": "As we did not go through Phase 1, we define our basic variables as the slack variables.",
        "phase_2_direct": "And our non-basic variables as the original problem variables. With this definition, we write:",
        "from_phase_1": "Since we came from phase 1, as previously stated, we will use the following set of basic and non-basic variables, defined by:",
        "max_text": "Maximum",
        "min_text": "Minimum",
        "conclusion_text": "Conclusion",
        "optimal_solution_text": "Thus, we conclude Phase 2 and obtain the optimal solution below:",
        "unbounded_solution_text": "As seen in the last iteration of Simplex, all values of $y$ were negative or equal to zero, indicating that the non-basic variable entering the basis can grow indefinitely, resulting in an unbounded solution.",
        "summarized_unbounded_text": "The problem is boundless",

        "numerical_solution_text": "We can calculate the corresponding solution for <x1> by multiplying the variable values by the cost vector, obtaining the optimal result <x1> = $<x2>$",
        "degenerate_solution": "Note that the solution is degenerate, meaning different choices in iterations <x1> could lead to the same result <x2> but with a different set of basic variables.",
        "maximum_iterations_exceeded_text": "Error: Maximum number of iterations reached.",
        "iteration_text": "Iteration <x1> (<x2>)",
        "current_status_text": "Current problem state:",
        "step_1_text": "Step 1: Calculation of the basic vector ($x_b$)",
        "step_1_details": "We invert the basic matrix and multiply it by the constraint vector:",
        "step_2_text": "Step 2: Calculation of the reduced costs ($c_r$)",
        "step_2_details": "The reduced cost vector is calculated as:",
        "step_3_text": "Step 3: Choose the variable entering the basis",
        "no_negative_pivot_found_details": "Since there are no candidates to enter the basis to improve the solution, we conclude the process.",
        "step_4_text": "Step 4: Calculation of the direction vector $y$",
        "step_4_details": "The vector $y$ is calculated as:",
        "step_4_variable_details": "$A_n$ is the column vector of constraints for the variable entering the basis.",
        "step_5_text": "Step 5: Choose the variable leaving the basis",
        "step_5_details": r"First, we calculate the ratios $\frac{x_b}{y}$, where $y \geq 0$, otherwise we consider it infinitely positive, arguing it will certainly not leave the basis.",
        "step_5_formula_variable": "Ratios",
        "phase_1_conclusion": "Phase 1 Conclusion",

        "get_negative_pivot_details": "The variable entering the basis is chosen as the element corresponding to the smallest negative number in the reduced cost vector $c_r$.",
        "get_negative_pivot_entering_element_details": "Element entering the basis $= min_{Negative} <x1> $",
        "get_negative_pivot_element_index_text": "Thus, we choose the element at index <x1> of the non-basic variables list $<x2>$ based on the reduced cost vector $c_r$.",
        "get_negative_pivot_chosen_element_text": "In other words, we conclude that $<x1>$ will enter the basis.",
        "get_negative_pivot_degeneracy": "Note that this is a degeneracy point, as we could choose other elements to enter the basis.",

        "get_positive_pivot_leaving_element_details": "Element leaving the basis $= min_{Positive} <x1> $",
        "get_positive_pivot_element_index_text": "Thus, we choose the element at index <x1> of the basic variables list $<x2>$ based on the column vector of ratios.",
        "get_positive_pivot_chosen_element_text": "In other words, we conclude that $<x1>$ will leave the basis.",
        "get_positive_pivot_degeneracy": "Note that this is a degeneracy point, as there are other equally viable options to leave the basis.",

        "problem_standardization_text": "Problem Standardization",
        "problem_standardization_details": "To solve the problem, we must first write it in standard form:",
        "problem_standardization_lt": "For an inequality of type $\leq$, we add only a slack variable.",
        "problem_standardization_eq": "For an equality $=$, we add only an artificial variable.",
        "problem_standardization_gt": "For an inequality of type $\geq$, we subtract a slack variable and add an artificial variable.",
        "problem_standardization_after": "After standardization, we obtain a constraint matrix in the following format:",
        "problem_standardization_result": "Then, we can write the problem in standard form as:",

        "maximize_text": "Maximize",
        "minimize_text": "Minimize",
        "subject_to_text": "Subject to",

        "optimal_solution_found": "Optimal solution found!",
        "values_text": "Values: ",
        "basic_variables_text": "Basic variables: ",
        "simple_degenerate_text": "The solution is degenerate, meaning there may be more than one set of basic variables.",
        "solution_file_id": "solution",
        "general_file_id": "general"
    }

    SPANISH_DICTIONARY = {
        "pt": "Portugués Brasileño",
        "en": "Inglés",
        "es": "Español",
        "return_to_main_menu": "Volver al menú principal",
        "solve_one": "Resolver un problema de Optimización Lineal",
        "solve_all": "Resolver todos los problemas de Optimización Lineal disponibles",
        "no_files": "No hay archivos disponibles para resolver.",
        "directory_not_exists": "El directorio especificado no existe.",
        "no_file_error": "Error: No se encontró ningún archivo.",
        "conv_all_confirmation": "Se han encontrado archivos <x1>, está seguro de que desea escribirlos todos en el documento LaTeX? (sí/no): ",
        "exercise_solved": "El problema <x1> ha sido resuelto y escrito en el documento LaTeX con éxito.",
        "all_exercises_solved": "Todos los problemas han sido resueltos y escritos en el documento LaTeX. \nDesea cerrar el programa? (sí/no): ",
        "select_file_intro": "Por favor, seleccione el archivo que desea resolver: ",
        "select_file_options": "Ingrese el número correspondiente al archivo: ",
        "show_steps": "Quieres ver los pasos de la solución? (s/n): ",
        "exit_text": "Cerrando el programa...",
        "exit_state": "Cerrar el programa.",
        "main_menu": "Seleccione una opción",
        "number_to_do": "Elija el número correspondiente a lo que desea hacer: ",
        "language_menu": "Elija un idioma",
        "language_options": "Elija el número correspondiente al idioma: ",
        "invalid_state": "Este menú no es válido.",
        "invalid_choice": "Elección no válida. Por favor, seleccione un número entre 1 y",
        "invalid_option_error": "Error: Entrada no válida. Por favor, ingrese un número válido.",

        "exercise_text": "Ejercicio: <x1>",
        "initial_problem_description": "El problema de optimización lineal puede describirse mediante las siguientes matrices y vectores:",
        "restriction_matrix_text": "Matriz de restricciones",
        "cost_vector_text": "Vector de costos",
        "restriction_vector_text": "Vector de restricciones",
        "cost_change_max_text": "Considerando que tenemos un problema de maximización, multiplicamos el vector de costos por $-1$, obteniendo:",
        "phase_one_text": "Fase 1",
        "phase_two_text": "Fase 2",
        "artificial_variables_removal": "Antes de proceder, necesitamos eliminar las variables artificiales y, para ello, resolvemos el problema auxiliar para obtener una base sin las variables artificiales.",
        "artificial_variables_cost": "Para lograr esto, supondremos temporalmente que el coste de todas las variables artificiales será igual a 1, mientras que las variables no artificiales costarán 0.",
        "initial_basic_non_basic_definition": "Comenzamos definiendo nuestras variables básicas y no básicas como $x_b$ y $x_n$, siguiendo la lógica:",
        "artificial_basis_definition": "Si la línea de la matriz tiene una variable artificial, la agregaremos al conjunto de variables básicas, y la variable de holgura correspondiente, al conjunto de variables no básicas. \n\n De lo contrario, agregaremos la variable de holgura directamente al conjunto de variables básicas.",
        "following_bases_text": "Haciendo esto, encontramos las siguientes bases:",

        "infeasible/phase_1_text": "Cuando terminamos el proceso de la fase 1, observamos que no fue posible eliminar las variables artificiales, por lo tanto, como no hay solución sin ellas, podemos concluir que el problema es inviable.",
        "summarized/infeasible/phase_1_text": "No fue posible eliminar las variables artificiales, problema inviable.",
        
        "infeasible/phase_2_text": "La solución óptima encontrada tiene valores negativos para las variables, lo que nos lleva a concluir que el problema es inviable.",
        "summarized/infeasible/phase_2_text": "La solución óptima tiene valores negativos, problema inviable.",

        "phase_1_success_text": "Así, concluimos la Fase 1 y obtenemos los siguientes valores para base inicial:",
        "phase_1_success_details": "Como logramos eliminar todas las variables artificiales de la base, completamos la fase 1 con éxito.",
        "phase_1_next_step": "Ahora podemos aprovechar estos resultados y volver al problema original..",
        "phase_1_skip": "Como no pasamos por la Fase 1, definimos nuestras variables básicas como las variables de holgura.",
        "phase_2_direct": "Y nuestras variables no básicas como las variables del problema original. Con esta definición, escribimos:",
        "from_phase_1": "Como venimos de la fase 1, como se dijo anteriormente, usaremos el siguiente conjunto de variables básicas y no básicas, definidas por:",
        "max_text": "Máximo",
        "min_text": "Mínimo",
        "conclusion_text": "Conclusión",
        "optimal_solution_text": "Así, concluimos la Fase 2 y obtenemos la solución óptima a continuación:",
        "unbounded_solution_text": "Como se observa en la última iteración del método Simplex, todos los valores de $y$ fueron negativos o igual a cero, indicando que la variable no básica que entra en la base puede crecer indefinidamente, resultando en una solución no acotada.",
        "summarized_unbounded_text": "El problema es ilimitado",

        "numerical_solution_text": "Podemos calcular la solución correspondiente para <x1> multiplicando los valores de las variables por el vector de costos, obteniendo el resultado óptimo <x1> = $<x2>$",
        "degenerate_solution": "Nota que la solución es degenerada, lo que significa que diferentes elecciones en iteraciones <x1> podrían llevar al mismo resultado <x2> pero con un conjunto diferente de variables básicas.",
        "maximum_iterations_exceeded_text": "Error: Se alcanzó el número máximo de iteraciones.",
        "iteration_text": "Iteración <x1> (<x2>)",
        "current_status_text": "Estado actual del problema:",
        "step_1_text": "Paso 1: Cálculo del vector básico ($x_b$)",
        "step_1_details": "Invertimos la matriz básica y la multiplicamos por el vector de restricciones:",
        "step_2_text": "Paso 2: Cálculo de los costos reducidos ($c_r$)",
        "step_2_details": "El vector de costos reducidos se calcula como:",
        "step_3_text": "Paso 3: Elegir la variable que entra en la base",
        "no_negative_pivot_found_details": "Como no hay candidatos para entrar en la base para mejorar la solución, concluimos el proceso.",
        "step_4_text": "Paso 4: Cálculo del vector de dirección $y$",
        "step_4_details": "El vector $y$ se calcula como:",
        "step_4_variable_details": "$A_n$ es el vector columna de restricciones para la variable que entra en la base.",
        "step_5_text": "Paso 5: Elegir la variable que sale de la base",
        "step_5_details": r"Primero, calculamos las razones $\frac{x_b}{y}$, donde $y \geq 0$, de lo contrario, lo consideramos infinitamente positivo, argumentando que ciertamente no saldrá de la base.",
        "step_5_formula_variable": "Razones",
        "phase_1_conclusion": "Conclusión de la Fase 1",

        "get_negative_pivot_details": "la variable que entra en la base se elige como el elemento correspondiente al menor número negativo en el vector de costos reducidos $c_r$.",
        "get_negative_pivot_entering_element_details": "Elemento que entra en la base $= min_{Negativo} <x1> $",
        "get_negative_pivot_element_index_text": "Así, elegimos el elemento en el índice <x1> de la lista de variables no básicas $<x2>$ basado en el vector de costos reducidos $c_r$.",
        "get_negative_pivot_chosen_element_text": "En otras palabras, concluimos que $<x1>$ entrará en la base.",
        "get_negative_pivot_degeneracy": "Nota que este es un punto de degeneración, ya que podríamos elegir otros elementos para entrar en la base.",

        "get_positive_pivot_leaving_element_details": "Elemento que sale de la base $= min_{Positivo} <x1> $",
        "get_positive_pivot_element_index_text": "Así, elegimos el elemento en el índice <x1> de la lista de variables básicas $<x2>$ basado en el vector columna de razones.",
        "get_positive_pivot_chosen_element_text": "En otras palabras, concluimos que $<x1>$ saldrá de la base.",
        "get_positive_pivot_degeneracy": "Nota que este es un punto de degeneración, ya que hay otras opciones igualmente viables para salir de la base.",

        "problem_standardization_text": "Estandarización del problema",
        "problem_standardization_details": "Para resolver el problema, primero debemos escribirlo en forma estándar:",
        "problem_standardization_lt": "Para una desigualdad del tipo $\leq$, agregamos solo una variable de holgura.",
        "problem_standardization_eq": "Para una igualdad $=$, agregamos solo una variable artificial.",
        "problem_standardization_gt": "Para una desigualdad del tipo $\geq$, restamos una variable de holgura y agregamos una variable artificial.",
        "problem_standardization_after": "Después de la estandarización, obtenemos una matriz de restricciones en el siguiente formato:",
        "problem_standardization_result": "Entonces, podemos escribir el problema en forma estándar como:",

        "maximize_text": "Maximizar",
        "minimize_text": "Minimizar",
        "subject_to_text": "Sujeto a",

        "optimal_solution_found": "¡Solución óptima encontrada!",
        "values_text": "Valores: ",
        "basic_variables_text": "Variables básicas: ",
        "simple_degenerate_text": "La solución es degenerada, lo que significa que puede haber más de un conjunto de variables básicas.",
        "solution_file_id": "solucion",
        "general_file_id": "general"
}


    LANGUAGE_REFERENCE = {
        "pt": PORTUGUESE_DICTIONARY,
        "en": ENGLISH_DICTIONARY,
        "es": SPANISH_DICTIONARY,
    }



    @staticmethod
    def get_text(key: str, language: str) -> str:
        try:
            return LanguageDictionary.LANGUAGE_REFERENCE[language][key]
        except KeyError:
            return "Tradução indisponível no momento."