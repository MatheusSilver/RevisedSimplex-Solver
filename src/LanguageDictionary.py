class LanguageDictionary:
    PORTUGUESE_DICTIONARY = {
        "pt": "Português Brasileiro",
        "en": "Inglês",
        "es": "Espanhol",
        "return_to_main_menu": "Voltar ao menu principal",
        "solve_one": "Resolver um problema de Otimização Linear",
        "solve_all": "Resolver todos os problemas de Otimização Linear disponíveis",
        "no_files": "Nenhum arquivo disponível para resolver.",
        "directory_not_exists": "O diretório especificado não existe.",
        "no_file_error": "Erro: Nenhum arquivo foi encontrado.",
        "select_file_intro": "Por favor, selecione o arquivo que deseja resolver: ",
        "select_file_options": "Digite o número correspondente ao arquivo: ",
        "show_steps": "Deseja visualizar os passos da resolução? (s/n): ",
        "exit_state": "Encerrando o programa...",
        "main_menu": "Selecione uma opção",
        "number_to_do": "Escolha o número correspondente ao que deseja fazer: ",
        "language_menu": "Escolha um idioma",
        "language_options": "Escolha o número correspondente ao idioma: ",
        "invalid_state": "Não é um menu válido.",
        "invalid_choice": "Escolha inválida. Por favor, selecione um número entre 1 e",
        "invalid_option_error": "Erro: Entrada inválida. Por favor, insira um número válido.",

        "exercise_text": "Exercício: <x1>",
        "initial_problem_description": "O problema de otimização linear pode ser descrito pelas seguintes matrizes e vetores:",
        "restriction_matrix_text": "Matriz de restrições",
        "cost_vector_text": "Vetor de custo",
        "restriction_vector_text": "Vetor de restrições",
        "cost_change_max_text": "Considerando termos um problema de maximização, multiplicamos o vetor de custos por $-1$, obtendo:",
        "phase_one_text": "Fase 1",
        "phase_two_text": "Fase 2",
        "artificial_variables_removal": "Antes de continuar, precisamos nos livrar das variáveis artificiais, e para isso, resolvemos o problema auxiliar de forma a obter uma base sem as variáveis artificiais.",
        "artificial_variables_cost": "Com esse objetivo, redefinimos o vetor de custos redefinindo o custo de todas as variáveis para zero, com exceção das variáveis artificiais que agora são custo 1.",
        "initial_basic_non_basic_definition": "Começamos definindo nossas variáveis básicas e não básicas por $x_b$ e $x_n$, seguindo a lógica de:",
        "artificial_basis_definition": "Se a linha da matriz possui uma variável artificial, então adicionamos a variável artificial ao conjunto de variáveis básicas, e a variável de folga no conjunto das não básicas.",
        "following_bases_text": "Fazendo isso, encontramos as seguintes bases:",

        "infeasible/phase_1_text": "Ao finalizarmos o processo da fase 1, não foi possível remover as variáveis artificiais, com isso, como não há uma solução sem elas, logo podemos concluir que o problema é inviável.",
        "infeasible/phase_2_text": "A solução ótima encontrada possui valores negativos para as variáveis, com isto, podemos concluir que o problema é inviável.",
        "phase_1_success_text": "Com isso, concluímos a fase 1, e obtemos a seguinte base inicial e com os seguintes valores:",
        "phase_1_success_details": "Como conseguimos remover todas as variáveis artificiais da base, concluímos a fase 1. A base atual é:",
        "phase_1_next_step": "Agora, podemos remover as variáveis artificiais do problema e resolver o problema original.",
        "phase_1_skip": "Como não passamos pela fase um, definimos nossas variáveis básicas como sendo as variáveis de folga.",
        "phase_2_direct": "E nossas variáveis não básicas como sendo as variáveis originais do problema, com tal definição, escrevemos:",
        "from_phase_1": "Como viemos da fase 1, então para continuar com a resolução do problema na fase 2, partiremos da solução encontrada na fase 1 definida por:",
        "max_text": "Máximo",
        "min_text": "Mínimo",
        "conclusion_text": "Conclusão",
        "optimal_solution_text": "Com isso, concluímos a fase 2, e obtemos a solução ótima abaixo:",
        "unbounded_solution_text": "Como vimos que na última iteração do Simplex, todos os valores de $y$ eram negativos, concluímos que a variável não básica que estará entrando poderá crescer indefinidamente, e portanto, teremos uma solução ilimitada.",
        "numerical_solution_text": "Podemos calcular a solução correspondente ao <x1>, multiplicando os valores das variáveis, pelo vetor de custo, e obtemos que o resultado ótimo atingível do problema é <x1> = $<x2>$",
        "degenerate_solution": "Observe que a solução é degenerada, isto é, se tivéssemos tomado escolhas diferentes nas iterações <x1>, de forma a obtermos o mesmo resultado <x2>, mas com outro conjunto de variáveis básicas.",
        "maximum_iterations_exceeded_text": "Erro: Número máximo de iterações atingido.",
        "iteration_text": "Iteração <x1> (<x2>)",
        "current_status_text": "Estado atual do problema:",
        "step_1_text": "Passo 1: Cálculo do vetor básico ($x_b$)",
        "step_1_details": "Invertemos a matriz básica e multiplicamos pelo vetor de restrições:",
        "step_2_text": "Passo 2: Cálculo dos custos reduzidos ($c_r$)",
        "step_2_details": "O vetor de custos reduzidos é calculado como:",
        "step_3_text": "Passo 3: Escolha da variável que entra na base",
        "no_negative_pivot_found_details": "Como não temos nenhum candidato a entrar na base de forma a melhorar a solução, concluímos o processo.",
        "step_4_text": "Passo 4: Cálculo do vetor direção $y$",
        "step_4_details": "O vetor $y$ é calculado como:",
        "step_4_variable_details": "$A_n$ é o vetor coluna das restrições da variável que irá entrar na base.",
        "step_5_text": "Passo 5: Escolha da variável que sai da base",
        "step_5_details": r"Primeiro, calculamos as razões $\frac{x_b}{y}$, onde $y \geq 0$, caso contrário iremos considerar como infinitamente positivo argumentando que ele certamente não será removido da base.",
        "step_5_formula_variable": "Razões",
        "phase_1_conclusion": "Conclusão da Fase 1",


        "get_negative_pivot_details": "O elemento a entrar na base é obtido ao procurarmos o elemento correspondente ao menor número negativo do vetor de custos reduzidos $c_r$ recém calculado.",
        "get_negative_pivot_entering_element_details": "Elemento a entrar na base $= min_{Negativo} <x1> $",
        "get_negative_pivot_element_index_text": "Com isso, escolhemos um elemento no índice <x1> da lista de variáveis não básicas $<x2>$ a partir do vetor de custos reduzidos $c_r$.",
        "get_negative_pivot_chosen_element_text": "Ou seja, concluímos que $<x1>$ entrará na base.",
        "get_negative_pivot_degeneracy": "Observe que aqui temos um ponto de degenerescência haja vista que podemos escolher outros elementos para entrar na base.",


        "get_positive_pivot_leaving_element_details": "Elemento a sair da base $= min_{Positivo} <x1> $",
        "get_positive_pivot_element_index_text": "Com isso, escolhemos um elemento no índice <x1> da lista de variáveis básicas $<x2>$ a partir do vetor coluna de razões.",
        "get_positive_pivot_chosen_element_text": "Ou seja, concluímos que $<x1>$ sairá da base.",
        "get_positive_pivot_degeneracy": "Observe que aqui temos um ponto de degenerescência haja vista que há outras opções igualmente benéficas para saírem da base.",

        "problem_standardization_text": "Padronização do Problema",
        "problem_standardization_details": "Para resolver o problema, precisamos primeiro escrevê-lo na forma padrão:",
        "problem_standardization_lt": "Para uma desigualdade do tipo $\leq$, adicionamos apenas uma variável de folga.",
        "problem_standardization_eq": "Para o caso de uma igualdade $=$, adicionamos apenas uma variável artificial.",
        "problem_standardization_gt": "Para o caso de uma desigualdade do tipo $\geq$, então subtraímos uma variável de folga e adicionamos uma variável artificial.",
        "problem_standardization_after": "Após a padronização, obteremos uma matriz de restrições no seguinte formato:",
        "problem_standardization_result": "E então, podemos escrever o problema na forma padrão como:",

        "maximize_text": "Maximizar",
        "minimize_text": "Minimizar",
        "subject_to_text": "Sujeito a",

        "optimal_solution_found": "Solução ótima encontrada!",
        "values_text": "Valores: ",
        "basic_variables_text": "Variáveis básicas: ",
        "simple_degenerate_text": "A solução é degenerada, isto é, pode haver mais do que um conjunto de variáveis básicas."
    }

    ENGLISH_DICTIONARY = {
        "pt": "Brazilian Portuguese",
        "en": "English",
        "es": "Spanish",
        "return_to_main_menu": "Return to main menu",
        "solve_one": "Solve a Linear Optimization problem",
        "solve_all": "Solve all available Linear Optimization problems",
        "no_files": "No files available to solve.",
        "directory_not_exists": "The specified directory does not exist.",
        "no_file_error": "Error: No file was found.",
        "select_file_intro": "Please select the file you want to solve:",
        "select_file_options": "Enter the corresponding number for the file: ",
        "show_steps": "Do you want to view the solution steps? (y/n): ",
        "exit_state": "Exiting the program...",
        "main_menu": "Select an option",
        "number_to_do": "Choose the number corresponding to what you want to do: ",
        "language_menu": "Choose a language",
        "language_options": "Choose the number corresponding to the language: ",
        "invalid_state": "This is not a valid menu.",
        "invalid_choice": "Invalid choice. Please select a number between 1 and",
        "invalid_option_error": "Error: Invalid input. Please enter a valid number.",

        "exercise_text": "Exercise: <x1>",
        "initial_problem_description": "The linear optimization problem can be described by the following matrices and vectors:",
        "restriction_matrix_text": "Constraint matrix",
        "cost_vector_text": "Cost vector",
        "restriction_vector_text": "Constraint vector",
        "cost_change_max_text": "Considering we have a maximization problem, we multiply the cost vector by $-1$, obtaining:",
        "phase_one_text": "Phase 1",
        "phase_two_text": "Phase 2",
        "artificial_variables_removal": "Before proceeding, we need to eliminate the artificial variables, and for this, we solve the auxiliary problem to obtain a basis without the artificial variables.",
        "artificial_variables_cost": "To achieve this, we redefine the cost vector by setting the cost of all variables to zero, except for the artificial variables, which now have a cost of 1.",
        "initial_basic_non_basic_definition": "We start by defining our basic and non-basic variables as $x_b$ and $x_n$, following the logic:",
        "artificial_basis_definition": "If the row of the matrix has an artificial variable, we add the artificial variable to the set of basic variables and the slack variable to the set of non-basic variables.",
        "following_bases_text": "Doing this, we find the following bases:",

        "infeasible/phase_1_text": "At the end of Phase 1, it was not possible to remove the artificial variables. As there is no solution without them, we conclude that the problem is infeasible.",
        "infeasible/phase_2_text": "The optimal solution found has negative values for the variables, leading us to conclude that the problem is infeasible.",
        "phase_1_success_text": "Thus, we conclude Phase 1 and obtain the following initial basis and values:",
        "phase_1_success_details": "Since we successfully removed all artificial variables from the basis, Phase 1 is concluded. The current basis is:",
        "phase_1_next_step": "Now, we can remove the artificial variables from the problem and solve the original problem.",
        "phase_1_skip": "As we did not go through Phase 1, we define our basic variables as the slack variables.",
        "phase_2_direct": "And our non-basic variables as the original problem variables. With this definition, we write:",
        "from_phase_1": "Since we come from Phase 1, we proceed to solve the problem in Phase 2 using the solution found in Phase 1, defined by:",
        "max_text": "Maximum",
        "min_text": "Minimum",
        "conclusion_text": "Conclusion",
        "optimal_solution_text": "Thus, we conclude Phase 2 and obtain the optimal solution below:",
        "unbounded_solution_text": "As seen in the last iteration of Simplex, all values of $y$ were negative, indicating that the non-basic variable entering the basis can grow indefinitely, resulting in an unbounded solution.",
        "numerical_solution_text": "We can calculate the corresponding solution for <x1> by multiplying the variable values by the cost vector, obtaining the optimal result <x1> = $<x2>$",
        "degenerate_solution": "Note that the solution is degenerate, meaning different choices in iterations <x1> could lead to the same result <x2> but with a different set of basic variables.",
        "maximum_iterations_exceeded_text": "Error: Maximum number of iterations reached.",
        "iteration_text": "Iteration <x1> (<x2>)",
        "current_status_text": "Current problem state:",
        "step_1_text": "Step 1: Calculation of the basic vector ($x_b$)",
        "step_1_details": "We invert the basic matrix and multiply it by the constraint vector:",
        "step_2_text": "Step 2: Calculation of the reduced costs ($c_r$)",
        "step_2_details": "The reduced cost vector is calculated as:",
        "step_3_text": "Step 3: Choose the variable entering the basis",
        "no_negative_pivot_found_details": "Since there are no candidates to enter the basis to improve the solution, we conclude the process.",
        "step_4_text": "Step 4: Calculation of the direction vector $y$",
        "step_4_details": "The vector $y$ is calculated as:",
        "step_4_variable_details": "$A_n$ is the column vector of constraints for the variable entering the basis.",
        "step_5_text": "Step 5: Choose the variable leaving the basis",
        "step_5_details": r"First, we calculate the ratios $\frac{x_b}{y}$, where $y \geq 0$, otherwise we consider it infinitely positive, arguing it will certainly not leave the basis.",
        "step_5_formula_variable": "Ratios",
        "phase_1_conclusion": "Phase 1 Conclusion",

        "get_negative_pivot_details": "The element entering the basis is chosen as the element corresponding to the smallest negative number in the reduced cost vector $c_r$.",
        "get_negative_pivot_entering_element_details": "Element entering the basis $= min_{Negative} <x1> $",
        "get_negative_pivot_element_index_text": "Thus, we choose an element at index <x1> of the non-basic variables list $<x2>$ based on the reduced cost vector $c_r$.",
        "get_negative_pivot_chosen_element_text": "In other words, we conclude that $<x1>$ will enter the basis.",
        "get_negative_pivot_degeneracy": "Note that this is a degeneracy point, as we could choose other elements to enter the basis.",

        "get_positive_pivot_leaving_element_details": "Element leaving the basis $= min_{Positive} <x1> $",
        "get_positive_pivot_element_index_text": "Thus, we choose an element at index <x1> of the basic variables list $<x2>$ based on the column vector of ratios.",
        "get_positive_pivot_chosen_element_text": "In other words, we conclude that $<x1>$ will leave the basis.",
        "get_positive_pivot_degeneracy": "Note that this is a degeneracy point, as there are other equally viable options to leave the basis.",

        "problem_standardization_text": "Problem Standardization",
        "problem_standardization_details": "To solve the problem, we must first write it in standard form:",
        "problem_standardization_lt": "For an inequality of type $\leq$, we add only a slack variable.",
        "problem_standardization_eq": "For an equality $=$, we add only an artificial variable.",
        "problem_standardization_gt": "For an inequality of type $\geq$, we subtract a slack variable and add an artificial variable.",
        "problem_standardization_after": "After standardization, we obtain a constraint matrix in the following format:",
        "problem_standardization_result": "Then, we can write the problem in standard form as:",

        "maximize_text": "Maximize",
        "minimize_text": "Minimize",
        "subject_to_text": "Subject to",

        "optimal_solution_found": "Optimal solution found!",
        "values_text": "Values: ",
        "basic_variables_text": "Basic variables: ",
        "simple_degenerate_text": "The solution is degenerate, meaning there may be more than one set of basic variables."
    }

    SPANISH_DICTIONARY = {
        "pt": "Portugués Brasileño",
        "en": "Inglés",
        "es": "Español",
        "return_to_main_menu": "Volver al menú principal",
        "solve_one": "Resolver un problema de Optimización Lineal",
        "solve_all": "Resolver todos los problemas de Optimización Lineal disponibles",
        "no_files": "No hay archivos disponibles para resolver.",
        "directory_not_exists": "El directorio especificado no existe.",
        "no_file_error": "Error: No se encontró ningún archivo.",
        "select_file_intro": "Por favor, seleccione el archivo que desea resolver: ",
        "select_file_options": "Ingrese el número correspondiente al archivo: ",
        "show_steps": "¿Quiere ver los pasos de la solución? (s/n): ",
        "exit_state": "Saliendo del programa...",
        "main_menu": "Seleccione una opción",
        "number_to_do": "Elija el número correspondiente a lo que desea hacer: ",
        "language_menu": "Elija un idioma",
        "language_options": "Elija el número correspondiente al idioma: ",
        "invalid_state": "Este menú no es válido.",
        "invalid_choice": "Elección no válida. Por favor, seleccione un número entre 1 y",
        "invalid_option_error": "Error: Entrada no válida. Por favor, ingrese un número válido.",

        "exercise_text": "Ejercicio: <x1>",
        "initial_problem_description": "El problema de optimización lineal puede describirse mediante las siguientes matrices y vectores:",
        "restriction_matrix_text": "Matriz de restricciones",
        "cost_vector_text": "Vector de costos",
        "restriction_vector_text": "Vector de restricciones",
        "cost_change_max_text": "Considerando que tenemos un problema de maximización, multiplicamos el vector de costos por $-1$, obteniendo:",
        "phase_one_text": "Fase 1",
        "phase_two_text": "Fase 2",
        "artificial_variables_removal": "Antes de proceder, necesitamos eliminar las variables artificiales y, para ello, resolvemos el problema auxiliar para obtener una base sin las variables artificiales.",
        "artificial_variables_cost": "Para lograr esto, redefinimos el vector de costos asignando un costo de 1 a las variables artificiales y un costo de 0 a todas las demás variables.",
        "initial_basic_non_basic_definition": "Comenzamos definiendo nuestras variables básicas y no básicas como $x_b$ y $x_n$, siguiendo la lógica:",
        "artificial_basis_definition": "Si una fila de la matriz contiene una variable artificial, agregamos la variable artificial al conjunto de variables básicas y la variable de holgura al conjunto de variables no básicas.",
        "following_bases_text": "Haciendo esto, encontramos las siguientes bases:",

        "infeasible/phase_1_text": "Al final de la Fase 1, no fue posible eliminar las variables artificiales. Como no hay solución sin ellas, concluimos que el problema es inviable.",
        "infeasible/phase_2_text": "La solución óptima encontrada tiene valores negativos para las variables, lo que nos lleva a concluir que el problema es inviable.",
        "phase_1_success_text": "Así, concluimos la Fase 1 y obtenemos la siguiente base inicial y valores:",
        "phase_1_success_details": "Como eliminamos exitosamente todas las variables artificiales de la base, la Fase 1 está concluida. La base actual es:",
        "phase_1_next_step": "Ahora podemos eliminar las variables artificiales del problema y resolver el problema original.",
        "phase_1_skip": "Como no pasamos por la Fase 1, definimos nuestras variables básicas como las variables de holgura.",
        "phase_2_direct": "Y nuestras variables no básicas como las variables del problema original. Con esta definición, escribimos:",
        "from_phase_1": "Como venimos de la Fase 1, procedemos a resolver el problema en la Fase 2 utilizando la solución encontrada en la Fase 1, definida por:",
        "max_text": "Máximo",
        "min_text": "Mínimo",
        "conclusion_text": "Conclusión",
        "optimal_solution_text": "Así, concluimos la Fase 2 y obtenemos la solución óptima a continuación:",
        "unbounded_solution_text": "Como se observa en la última iteración del método Simplex, todos los valores de $y$ fueron negativos, indicando que la variable no básica que entra en la base puede crecer indefinidamente, resultando en una solución no acotada.",
        "numerical_solution_text": "Podemos calcular la solución correspondiente para <x1> multiplicando los valores de las variables por el vector de costos, obteniendo el resultado óptimo <x1> = $<x2>$",
        "degenerate_solution": "Nota que la solución es degenerada, lo que significa que diferentes elecciones en iteraciones <x1> podrían llevar al mismo resultado <x2> pero con un conjunto diferente de variables básicas.",
        "maximum_iterations_exceeded_text": "Error: Se alcanzó el número máximo de iteraciones.",
        "iteration_text": "Iteración <x1> (<x2>)",
        "current_status_text": "Estado actual del problema:",
        "step_1_text": "Paso 1: Cálculo del vector básico ($x_b$)",
        "step_1_details": "Invertimos la matriz básica y la multiplicamos por el vector de restricciones:",
        "step_2_text": "Paso 2: Cálculo de los costos reducidos ($c_r$)",
        "step_2_details": "El vector de costos reducidos se calcula como:",
        "step_3_text": "Paso 3: Elegir la variable que entra en la base",
        "no_negative_pivot_found_details": "Como no hay candidatos para entrar en la base para mejorar la solución, concluimos el proceso.",
        "step_4_text": "Paso 4: Cálculo del vector de dirección $y$",
        "step_4_details": "El vector $y$ se calcula como:",
        "step_4_variable_details": "$A_n$ es el vector columna de restricciones para la variable que entra en la base.",
        "step_5_text": "Paso 5: Elegir la variable que sale de la base",
        "step_5_details": r"Primero, calculamos las razones $\frac{x_b}{y}$, donde $y \geq 0$, de lo contrario, lo consideramos infinitamente positivo, argumentando que ciertamente no saldrá de la base.",
        "step_5_formula_variable": "Razones",
        "phase_1_conclusion": "Conclusión de la Fase 1",

        "get_negative_pivot_details": "El elemento que entra en la base se elige como el elemento correspondiente al menor número negativo en el vector de costos reducidos $c_r$.",
        "get_negative_pivot_entering_element_details": "Elemento que entra en la base $= min_{Negativo} <x1> $",
        "get_negative_pivot_element_index_text": "Así, elegimos un elemento en el índice <x1> de la lista de variables no básicas $<x2>$ basado en el vector de costos reducidos $c_r$.",
        "get_negative_pivot_chosen_element_text": "En otras palabras, concluimos que $<x1>$ entrará en la base.",
        "get_negative_pivot_degeneracy": "Nota que este es un punto de degeneración, ya que podríamos elegir otros elementos para entrar en la base.",

        "get_positive_pivot_leaving_element_details": "Elemento que sale de la base $= min_{Positivo} <x1> $",
        "get_positive_pivot_element_index_text": "Así, elegimos un elemento en el índice <x1> de la lista de variables básicas $<x2>$ basado en el vector columna de razones.",
        "get_positive_pivot_chosen_element_text": "En otras palabras, concluimos que $<x1>$ saldrá de la base.",
        "get_positive_pivot_degeneracy": "Nota que este es un punto de degeneración, ya que hay otras opciones igualmente viables para salir de la base.",

        "problem_standardization_text": "Estandarización del problema",
        "problem_standardization_details": "Para resolver el problema, primero debemos escribirlo en forma estándar:",
        "problem_standardization_lt": "Para una desigualdad del tipo $\leq$, agregamos solo una variable de holgura.",
        "problem_standardization_eq": "Para una igualdad $=$, agregamos solo una variable artificial.",
        "problem_standardization_gt": "Para una desigualdad del tipo $\geq$, restamos una variable de holgura y agregamos una variable artificial.",
        "problem_standardization_after": "Después de la estandarización, obtenemos una matriz de restricciones en el siguiente formato:",
        "problem_standardization_result": "Entonces, podemos escribir el problema en forma estándar como:",

        "maximize_text": "Maximizar",
        "minimize_text": "Minimizar",
        "subject_to_text": "Sujeto a",

        "optimal_solution_found": "¡Solución óptima encontrada!",
        "values_text": "Valores: ",
        "basic_variables_text": "Variables básicas: ",
        "simple_degenerate_text": "La solución es degenerada, lo que significa que puede haber más de un conjunto de variables básicas."
}


    LANGUAGE_REFERENCE = {
        "pt": PORTUGUESE_DICTIONARY,
        "en": ENGLISH_DICTIONARY,
        "es": SPANISH_DICTIONARY,
    }



    @staticmethod
    def get_text(key: str, language: str) -> str:
        try:
            return LanguageDictionary.LANGUAGE_REFERENCE[language][key]
        except KeyError:
            return "Tradução indisponível no momento."