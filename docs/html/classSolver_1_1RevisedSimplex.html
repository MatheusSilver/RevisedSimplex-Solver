<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simplex Solver Simplificado: Solver.RevisedSimplex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simplex Solver Simplificado
   </div>
   <div id="projectbrief">Um projeto didático para resolver problemas de otimização linear com o método simplex revisado, gerando explicações detalhadas em LaTeX.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSolver_1_1RevisedSimplex.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSolver_1_1RevisedSimplex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Solver.RevisedSimplex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Solver.RevisedSimplex:</div>
<div class="dyncontent">
<div class="center"><img src="classSolver_1_1RevisedSimplex__inherit__graph.png" border="0" usemap="#aSolver_8RevisedSimplex_inherit__map" alt="Inheritance graph"/></div>
<map name="aSolver_8RevisedSimplex_inherit__map" id="aSolver_8RevisedSimplex_inherit__map">
<area shape="rect" title=" " alt="" coords="25,5,231,523"/>
<area shape="rect" href="classSolver_1_1RevisedSimplexWithoutFile.html" title=" " alt="" coords="5,571,251,721"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for Solver.RevisedSimplex:</div>
<div class="dyncontent">
<div class="center"><img src="classSolver_1_1RevisedSimplex__coll__graph.png" border="0" usemap="#aSolver_8RevisedSimplex_coll__map" alt="Collaboration graph"/></div>
<map name="aSolver_8RevisedSimplex_coll__map" id="aSolver_8RevisedSimplex_coll__map">
<area shape="rect" title=" " alt="" coords="5,5,212,523"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a79c7e4d746c2723a6f19c6e551f86950"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a79c7e4d746c2723a6f19c6e551f86950">__init__</a> (self, str file=&quot;&quot;, bool show_steps=False, LatexWriter latex_writer=None)</td></tr>
<tr class="separator:a79c7e4d746c2723a6f19c6e551f86950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18e8bb26b40d183a4414ebf4bceee72"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ac18e8bb26b40d183a4414ebf4bceee72">reload_problem</a> (self, str file)</td></tr>
<tr class="separator:ac18e8bb26b40d183a4414ebf4bceee72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ad34b6cb6a487c97cb3f69d69062da"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ad6ad34b6cb6a487c97cb3f69d69062da">solve</a> (self, bool show_steps=False)</td></tr>
<tr class="separator:ad6ad34b6cb6a487c97cb3f69d69062da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bb9e61fa0cb4695d850422334a55e2"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ad7bb9e61fa0cb4695d850422334a55e2">get_solution</a> (self)</td></tr>
<tr class="separator:ad7bb9e61fa0cb4695d850422334a55e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb9c8edf4106fac8345cee091361a79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a2fb9c8edf4106fac8345cee091361a79">set_next_exercise</a> (self)</td></tr>
<tr class="separator:a2fb9c8edf4106fac8345cee091361a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a14d6b31f2c11c39bbfcc828c20b3dade"><td class="memItemLeft" align="right" valign="top"><a id="a14d6b31f2c11c39bbfcc828c20b3dade"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>should_close</b></td></tr>
<tr class="separator:a14d6b31f2c11c39bbfcc828c20b3dade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba56960fb59b4d97911e4d3bbbcbc1e7"><td class="memItemLeft" align="right" valign="top"><a id="aba56960fb59b4d97911e4d3bbbcbc1e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>latexWriter</b></td></tr>
<tr class="separator:aba56960fb59b4d97911e4d3bbbcbc1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bb83e183148fef8d997ea17a96355a"><td class="memItemLeft" align="right" valign="top"><a id="ab3bb83e183148fef8d997ea17a96355a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>variable_values</b></td></tr>
<tr class="separator:ab3bb83e183148fef8d997ea17a96355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23fb48d030b160c3e7563f7401336f2"><td class="memItemLeft" align="right" valign="top"><a id="ab23fb48d030b160c3e7563f7401336f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>slack_variables</b></td></tr>
<tr class="separator:ab23fb48d030b160c3e7563f7401336f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95374ec3be9980eaa362b4b1785dee99"><td class="memItemLeft" align="right" valign="top"><a id="a95374ec3be9980eaa362b4b1785dee99"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>artificial_variables</b></td></tr>
<tr class="separator:a95374ec3be9980eaa362b4b1785dee99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b4e92ec9686cf80f3400ed31fb1bc"><td class="memItemLeft" align="right" valign="top"><a id="a2f4b4e92ec9686cf80f3400ed31fb1bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>status</b></td></tr>
<tr class="separator:a2f4b4e92ec9686cf80f3400ed31fb1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09df57c1b59aeec97d290e9cb35e0137"><td class="memItemLeft" align="right" valign="top"><a id="a09df57c1b59aeec97d290e9cb35e0137"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>degeneracy_points</b></td></tr>
<tr class="separator:a09df57c1b59aeec97d290e9cb35e0137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06cc15e825311373d2a0bfae617b5c7"><td class="memItemLeft" align="right" valign="top"><a id="ad06cc15e825311373d2a0bfae617b5c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>current_interaction</b></td></tr>
<tr class="separator:ad06cc15e825311373d2a0bfae617b5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08537c4cecd1083a0cae38bae3454ab"><td class="memItemLeft" align="right" valign="top"><a id="ad08537c4cecd1083a0cae38bae3454ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>variables</b></td></tr>
<tr class="separator:ad08537c4cecd1083a0cae38bae3454ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad836933e77c7f25a7356d065b7ffcbb7"><td class="memItemLeft" align="right" valign="top"><a id="ad836933e77c7f25a7356d065b7ffcbb7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>constraint_matrix</b></td></tr>
<tr class="separator:ad836933e77c7f25a7356d065b7ffcbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905ab3baa0c2b7efac22aed3964665bc"><td class="memItemLeft" align="right" valign="top"><a id="a905ab3baa0c2b7efac22aed3964665bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>isMaximization</b></td></tr>
<tr class="separator:a905ab3baa0c2b7efac22aed3964665bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b09441acf4343165a558e2bfaa5b73"><td class="memItemLeft" align="right" valign="top"><a id="ae3b09441acf4343165a558e2bfaa5b73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>objective</b></td></tr>
<tr class="separator:ae3b09441acf4343165a558e2bfaa5b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0be177907ba917dcad31bc9d3b9e1f"><td class="memItemLeft" align="right" valign="top"><a id="a0b0be177907ba917dcad31bc9d3b9e1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>restrictions</b></td></tr>
<tr class="separator:a0b0be177907ba917dcad31bc9d3b9e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84081decc1b854c39e1f0d87c5c20b19"><td class="memItemLeft" align="right" valign="top"><a id="a84081decc1b854c39e1f0d87c5c20b19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>restriction_symbols</b></td></tr>
<tr class="separator:a84081decc1b854c39e1f0d87c5c20b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af990dd59207cb086143762f90000fee9"><td class="memItemLeft" align="right" valign="top"><a id="af990dd59207cb086143762f90000fee9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basis</b></td></tr>
<tr class="separator:af990dd59207cb086143762f90000fee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dae3b0f33b1ff9a186cd64167bdf40"><td class="memItemLeft" align="right" valign="top"><a id="ab6dae3b0f33b1ff9a186cd64167bdf40"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>non_basis</b></td></tr>
<tr class="separator:ab6dae3b0f33b1ff9a186cd64167bdf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:add1c93bdffb634a053090303a147fee9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#add1c93bdffb634a053090303a147fee9">_load_problem_data</a> (self, str file)</td></tr>
<tr class="separator:add1c93bdffb634a053090303a147fee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2911bc5e52dff2c455a2e721f883247"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#aa2911bc5e52dff2c455a2e721f883247">_setup_support_variables</a> (self)</td></tr>
<tr class="separator:aa2911bc5e52dff2c455a2e721f883247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a01e2b9ecdd4fac9bba86225351abc"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ae9a01e2b9ecdd4fac9bba86225351abc">__setup_from_data</a> (self, data)</td></tr>
<tr class="separator:ae9a01e2b9ecdd4fac9bba86225351abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8efd507c57fd1b6e1415a1104aaa7a"><td class="memItemLeft" align="right" valign="top">list[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#abf8efd507c57fd1b6e1415a1104aaa7a">__get_initial_artificial_basis</a> (self)</td></tr>
<tr class="separator:abf8efd507c57fd1b6e1415a1104aaa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35d8f3aff5009b95a2a1b7722bec1cf"><td class="memItemLeft" align="right" valign="top">list[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ab35d8f3aff5009b95a2a1b7722bec1cf">__get_initial_artificial_non_basis</a> (self, list[str] initial_basis)</td></tr>
<tr class="separator:ab35d8f3aff5009b95a2a1b7722bec1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d733abace2ffd0b747692d59d3439f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a76d733abace2ffd0b747692d59d3439f">__solve_phase_one</a> (self, bool show_steps=False)</td></tr>
<tr class="separator:a76d733abace2ffd0b747692d59d3439f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74656209d027685de91405351566ecf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a74656209d027685de91405351566ecf1">__check_infeasibility_phase_one</a> (self)</td></tr>
<tr class="separator:a74656209d027685de91405351566ecf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9ab746ff251a96092aa6e62dc93146"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a8c9ab746ff251a96092aa6e62dc93146">__solve_phase_two</a> (self, bool from_phase_one, bool show_steps=False)</td></tr>
<tr class="separator:a8c9ab746ff251a96092aa6e62dc93146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb45958124682c0418daac73a5759e1c"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#abb45958124682c0418daac73a5759e1c">__show_process_results</a> (self, bool show_steps=False)</td></tr>
<tr class="separator:abb45958124682c0418daac73a5759e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f0ef6248dd5be8154e99c19df8f643"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a11f0ef6248dd5be8154e99c19df8f643">__check_infeasibility_phase_two</a> (self)</td></tr>
<tr class="separator:a11f0ef6248dd5be8154e99c19df8f643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274b595d119eb9e7b40b7fcd49a3e7a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a274b595d119eb9e7b40b7fcd49a3e7a3">__solver_loop</a> (self, np.ndarray[np.float64] basic_matrix, list[int] basic_indexes, list[int] non_basic_indexes, np.array(np.float64) profit_vector, np.ndarray[np.float64] restrictions_vector, bool is_phase_one, bool show_steps=False)</td></tr>
<tr class="separator:a274b595d119eb9e7b40b7fcd49a3e7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b81203e609fc44217d9dfdd257d8b4"><td class="memItemLeft" align="right" valign="top">(int, int)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a85b81203e609fc44217d9dfdd257d8b4">__update_variable_values</a> (self, basic_indexes, list[str] variables_list, x_b, y, out_index, in_index_non_basic, out_index_basic)</td></tr>
<tr class="separator:a85b81203e609fc44217d9dfdd257d8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd0709b313ccd11a32f285676ccd349"><td class="memItemLeft" align="right" valign="top">np.ndarray[np.float64]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#aedd0709b313ccd11a32f285676ccd349">__get_basic_matrix</a> (self, list[int] basic_indexes)</td></tr>
<tr class="separator:aedd0709b313ccd11a32f285676ccd349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a7b88ca866dfbf3678b23d311f8add"><td class="memItemLeft" align="right" valign="top">list[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a92a7b88ca866dfbf3678b23d311f8add">__get_basic_indexes</a> (self)</td></tr>
<tr class="separator:a92a7b88ca866dfbf3678b23d311f8add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35c4803a7fa8e860414360ab58a4b18"><td class="memItemLeft" align="right" valign="top">list[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ac35c4803a7fa8e860414360ab58a4b18">__get_non_basic_indexes</a> (self)</td></tr>
<tr class="separator:ac35c4803a7fa8e860414360ab58a4b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e95c4e43b310d7d20dbd9cb560ff13f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a7e95c4e43b310d7d20dbd9cb560ff13f">__get_negative_pivot</a> (self, np.ndarray[np.float64] reduced_costs, bool show_steps=False)</td></tr>
<tr class="separator:a7e95c4e43b310d7d20dbd9cb560ff13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a0cdf4862a5bbe98dd1f448bd707f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a93a0cdf4862a5bbe98dd1f448bd707f6">__get_positive_pivot</a> (self, np.array(np.float64) ratios, bool show_steps=False)</td></tr>
<tr class="separator:a93a0cdf4862a5bbe98dd1f448bd707f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba69122232d92b4ed294447f156799ac"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#aba69122232d92b4ed294447f156799ac">__standardize_problem</a> (self, bool show_steps=False)</td></tr>
<tr class="separator:aba69122232d92b4ed294447f156799ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0233c37d2b196bc7d77ccdfe588aa692"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a0233c37d2b196bc7d77ccdfe588aa692">__add_variable_to_matrix</a> (self, int line_to_add, int value)</td></tr>
<tr class="separator:a0233c37d2b196bc7d77ccdfe588aa692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde8769511e745db0e0d88170d382607"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#afde8769511e745db0e0d88170d382607">__add_variable_value_to_vector</a> (self, int line_to_add, int value)</td></tr>
<tr class="separator:afde8769511e745db0e0d88170d382607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7739a026866f8a50743e8208254101"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#aaa7739a026866f8a50743e8208254101">__remove_artificial_variables</a> (self)</td></tr>
<tr class="separator:aaa7739a026866f8a50743e8208254101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290b7c7b732387f9c427a47a84623fa0"><td class="memItemLeft" align="right" valign="top">list[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a290b7c7b732387f9c427a47a84623fa0">__get_variables_list</a> (self)</td></tr>
<tr class="separator:a290b7c7b732387f9c427a47a84623fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769048999453ff3f9f2c2ea9c7aafa95"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a769048999453ff3f9f2c2ea9c7aafa95">__get_degenerate_string</a> (self)</td></tr>
<tr class="separator:a769048999453ff3f9f2c2ea9c7aafa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c401232d61ead557453cfe9d326304"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a82c401232d61ead557453cfe9d326304">__print_current_exercise_status</a> (self, str status)</td></tr>
<tr class="separator:a82c401232d61ead557453cfe9d326304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e379031ec684055348de42faa107bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a37e379031ec684055348de42faa107bf">__write_current_problem</a> (self)</td></tr>
<tr class="separator:a37e379031ec684055348de42faa107bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a40e1e8a4949eb8b04f184c6e31e70bf9"><td class="memItemLeft" align="right" valign="top"><a id="a40e1e8a4949eb8b04f184c6e31e70bf9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__exercise_number</b></td></tr>
<tr class="separator:a40e1e8a4949eb8b04f184c6e31e70bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@class RevisedSimplex
@brief Classe para resolver problemas de programação linear com o Simplex Revisado.

@details
Esta classe lida com as principais etapas do algoritmo Simplex Revisado:
- Padronização do problema (adição de variáveis de folga ou artificiais),
- Fase 1: Remoção de variáveis artificiais,
- Fase 2: Busca pela solução ótima.
Também permite a exportação dos resultados em LaTeX para facilitar relatórios e análises.

@note
Esta classe é dependente do fornecimento de um arquivo com os dados do problema.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a79c7e4d746c2723a6f19c6e551f86950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c7e4d746c2723a6f19c6e551f86950">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>file</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LatexWriter &#160;</td>
          <td class="paramname"><em>latex_writer</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">@brief Construtor da classe RevisedSimplex.

@param file Nome do arquivo que contém os dados do problema de otimização linear.
O padrão é uma string vazia (não utiliza arquivo).
@param show_steps Indica se os passos intermediários do processo devem ser exibidos no LaTeX.
@param latex_writer Instância de LatexWriter para gerar a saída em LaTeX. Opcional caso mais de um problema vá ser resolvido.

@details
Este construtor inicializa e configura a classe RevisedSimplex. Ele pode usar informações de um arquivo
ou ser configurado manualmente através de sua classe filha para resolver problemas lineares passados através de uma matriz.

@see RevisedSimplexWithoutFile
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0233c37d2b196bc7d77ccdfe588aa692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0233c37d2b196bc7d77ccdfe588aa692">&#9670;&nbsp;</a></span>__add_variable_to_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__add_variable_to_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Adiciona uma nova variável (folga ou artificial) à matriz de restrições.

    @param line_to_add Índice da linha onde a variável deve ser adicionada.
    @param value O valor do multiplicador da variável na matriz (1 para folga ou -1 caso uma variável artificial esteja presente).

    @details
    Este método modifica a matriz de restrições (A) e ajusta o vetor de variáveis com
    a adição de novas colunas representando as variáveis introduzidas na padronização.

    @note Este método é uma etapa necessária durante a padronização do problema.
</pre> 
</div>
</div>
<a id="afde8769511e745db0e0d88170d382607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde8769511e745db0e0d88170d382607">&#9670;&nbsp;</a></span>__add_variable_value_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__add_variable_value_to_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Adiciona o valor inicial de uma variável no vetor de valores das variáveis.

    @param line_to_add Linha de dada variável na matriz de restrições.
    @param value Multiplicador específico para a variável adicionada.

    @details
    Esse método ajusta os valores iniciais do vetor de variáveis com base na
    linha da matriz de restrições onde a nova variável foi introduzida.

    - Se a variável é uma variável de folga mas com multiplicador (`-1`),
      o valor é automaticamente ajustado como `0`.
    - Caso contrário, usa o valor correspondente multiplicador no vetor de restrições (`1` geralmente).

    @note Essa função é usada durante a inicialização das variáveis no problema padronizado.
</pre> 
</div>
</div>
<a id="a74656209d027685de91405351566ecf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74656209d027685de91405351566ecf1">&#9670;&nbsp;</a></span>__check_infeasibility_phase_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool Solver.RevisedSimplex.__check_infeasibility_phase_one </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Verifica a inviabilidade do problema durante a Fase 1.

    @return Retorna `True` se o problema for inviável, `False` caso contrário.

    @details
    Esse método analisa se ainda há variáveis artificiais na base ou
    se algum valores dessas variáveis é diferente de 0.
    Se ambas as condições não forem satisfeitas, então o problema é viável e procedemos para a segunda fase.
</pre> 
</div>
</div>
<a id="a11f0ef6248dd5be8154e99c19df8f643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f0ef6248dd5be8154e99c19df8f643">&#9670;&nbsp;</a></span>__check_infeasibility_phase_two()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def Solver.RevisedSimplex.__check_infeasibility_phase_two </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Verifica a inviabilidade do problema ao final da Fase 2.

    @return Retorna `True` se o problema for inviável, `False` caso contrário.

    @details
    Esse método analisa se alguma variável possui valores negativos.
    Caso não possua, então o problema é viável e procedemos para a elucidação dos resultados.
</pre> 
</div>
</div>
<a id="a92a7b88ca866dfbf3678b23d311f8add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a7b88ca866dfbf3678b23d311f8add">&#9670;&nbsp;</a></span>__get_basic_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[int] Solver.RevisedSimplex.__get_basic_indexes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Retorna os índices das variáveis básicas no problema.

    @return Uma lista de índices das variáveis que compõem a base atual na
            lista de todas as variáveis do problema.

    @details
    Esse método acessa a lista de variáveis básicas e retorna os respectivos índices consoante
    à lista concatenada de todas as variáveis do problema.

    @note Utilizada na obtenção da matriz básica em cada iteração.
</pre> 
</div>
</div>
<a id="aedd0709b313ccd11a32f285676ccd349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd0709b313ccd11a32f285676ccd349">&#9670;&nbsp;</a></span>__get_basic_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray[np.float64] Solver.RevisedSimplex.__get_basic_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[int]&#160;</td>
          <td class="paramname"><em>basic_indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Obtém a matriz das variáveis básicas usando os índices fornecidos.

    @param basic_indexes Lista com os índices das variáveis básicas na matriz de restrições.
    @return A matriz de restrições apenas com as colunas correspondentes as variáveis básicas.

    @details
    Usa os índices passados para selecionar as colunas da matriz de restrições
    que correspondem às variáveis atuais da base.
</pre> 
</div>
</div>
<a id="a769048999453ff3f9f2c2ea9c7aafa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769048999453ff3f9f2c2ea9c7aafa95">&#9670;&nbsp;</a></span>__get_degenerate_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> str Solver.RevisedSimplex.__get_degenerate_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Retorna uma string representando os pontos de degeneração ocorridos durante o processo separados por vírgula.

    @return Uma string contendo os índices das interações que resultaram em degeneração.

    @details
    O método constrói uma string formatada que lista, por iteração, os pontos
    onde a degeneração foi identificada. Usado especialmente para apresentar
    os pontos onde diferentes escolhas poderiam ser tomadas para resolver o problema.

    @warning Deve ser usado somente após uma iteração com degeneração.
</pre> 
</div>
</div>
<a id="abf8efd507c57fd1b6e1415a1104aaa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8efd507c57fd1b6e1415a1104aaa7a">&#9670;&nbsp;</a></span>__get_initial_artificial_basis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[str] Solver.RevisedSimplex.__get_initial_artificial_basis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Obtém a base inicial com variáveis artificiais para a Fase 1.

    @return Uma lista contendo a base factível inicial do problema para a Fase 1.

    @details
    Durante a Fase 1, as variáveis artificiais são inseridas na base inicial para resolver o problema.
    Este método retorna a base inicial factível com base na matriz de restrições fornecida
    A ordem das linhas e adições de variável de folga e artificial é respeitada durante a construção.
</pre> 
</div>
</div>
<a id="ab35d8f3aff5009b95a2a1b7722bec1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35d8f3aff5009b95a2a1b7722bec1cf">&#9670;&nbsp;</a></span>__get_initial_artificial_non_basis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[str] Solver.RevisedSimplex.__get_initial_artificial_non_basis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str]&#160;</td>
          <td class="paramname"><em>initial_basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Obtém o conjunto de variáveis não basicas inicial complementando a base inicial.

    @param initial_basis Lista contendo o conjunto de variáveis básicas inicial.
    @return Lista com as variáveis que não estão na base factível inicial.

    @details
    As variáveis que não estão na base inicial factível são classificadas como não básicas no início do algoritmo.
    Esse método retorna essas variáveis com base nas variáveis básicas para ser usado em iterações posteriores.

    @warning Deve ser executado após obter a base inicial.
    @see __get_initial_artificial_basis
</pre> 
</div>
</div>
<a id="a7e95c4e43b310d7d20dbd9cb560ff13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e95c4e43b310d7d20dbd9cb560ff13f">&#9670;&nbsp;</a></span>__get_negative_pivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int Solver.RevisedSimplex.__get_negative_pivot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray[np.float64]&#160;</td>
          <td class="paramname"><em>reduced_costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Determina o índice da variável que entrará na base (pivô de entrada).

    @param reduced_costs Um vetor contendo os custos reduzidos das variáveis não básicas.
    @param show_steps Booleano que indica se os detalhes do processo serão escritos no LaTeX.

    @return Retorna o índice da variável não básica com menor custo reduzido (menor valor negativo):
        - Índice inteiro do pivô escolhido,
        - `-1` se não houver valores negativos (indica que a solução é ótima).

    @details
    Identifica a variável que entrará na base ao procurar o menor valor negativo em
    `reduced_costs`. Este valor define a direção de melhoria para o custo da função objetivo.
    1. Valores negativos em `reduced_costs` indicam possíveis melhorias no custo.
    2. O pivô é selecionado com base no menor custo reduzido negativo.
    3. Se houver múltiplos candidatos com o mesmo valor, o método detecta
    degeneração, e registra a iteração em que ocorreu.
</pre> 
</div>
</div>
<a id="ac35c4803a7fa8e860414360ab58a4b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35c4803a7fa8e860414360ab58a4b18">&#9670;&nbsp;</a></span>__get_non_basic_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[int] Solver.RevisedSimplex.__get_non_basic_indexes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Retorna os índices das variáveis não básicas no problema.

    @return Uma lista de índices das variáveis que não compõem a base atual na
            lista de todas as variáveis do problema.

    @details
    Funciona de forma similar a `__get_basic_indexes`, mas acessa diretamente
    as variáveis classificadas como não básicas e retorna seus índices.

    @note Utilizada no calculo dos custos reduzidos em cada iteração.
</pre> 
</div>
</div>
<a id="a93a0cdf4862a5bbe98dd1f448bd707f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a0cdf4862a5bbe98dd1f448bd707f6">&#9670;&nbsp;</a></span>__get_positive_pivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int Solver.RevisedSimplex.__get_positive_pivot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.array(np.float64)&#160;</td>
          <td class="paramname"><em>ratios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Determina o índice da variável que sairá da base (pivô de saída).

    @param ratios Um vetor contendo os coeficientes das razões entre as variáveis básicas (`x_b`)
    e os valores correspondentes em `y`.

    @param show_steps Booleano que indica se os detalhes do método serão escritos no LaTeX.

    @return Retorna o índice da variável básica que será removida da base:
        - Índice inteiro do pivô escolhido para sair,
        - `-1` se não houver índices válidos (indica problema ilimitado).

    @details
    Este método calcula o pivô de saída seguindo o critério da razão mínima,
    onde as razões `x_b / y` são analisadas. Apenas valores positivos em `y` são
    considerados:
    1. O menor valor da razão determina o pivô que sairá.
    2. Em casos onde há múltiplos mínimos, a degeneração é identificada
    para que seja rastreada durante o processo.
</pre> 
</div>
</div>
<a id="a290b7c7b732387f9c427a47a84623fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290b7c7b732387f9c427a47a84623fa0">&#9670;&nbsp;</a></span>__get_variables_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[str] Solver.RevisedSimplex.__get_variables_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Retorna a lista completa de variáveis no problema.

    @return Uma lista contendo os nomes das variáveis originais, de folga e artificiais,
    nesta exata ordem de concatenação.
</pre> 
</div>
</div>
<a id="a82c401232d61ead557453cfe9d326304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c401232d61ead557453cfe9d326304">&#9670;&nbsp;</a></span>__print_current_exercise_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__print_current_exercise_status </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">@brief Identifica o exercício e imprime o status da tela.

@param status identificador do erro ou da conclusão obtida durante a execução do algoritmo.

@details
Imprime de forma simplificada o identificador do exercício atual,
e faz um leve detalhamento do seu status atual.
</pre> 
</div>
</div>
<a id="aaa7739a026866f8a50743e8208254101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7739a026866f8a50743e8208254101">&#9670;&nbsp;</a></span>__remove_artificial_variables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def Solver.RevisedSimplex.__remove_artificial_variables </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">@brief Remove as variáveis artificiais de todos os lugares do problema

@details
Este método só é executado após a conclusão bem sucedida da Fase 1, garantindo que
as variáveis artificiais não sejam consideradas durante a Fase 2
para além de facilitar a visualização e elucidação da Fase 2 como seria feito manualmente.

@note Deve ser chamado APENAS após a finalização da Fase 1 bem sucedida da Fase 1.
</pre> 
</div>
</div>
<a id="ae9a01e2b9ecdd4fac9bba86225351abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a01e2b9ecdd4fac9bba86225351abc">&#9670;&nbsp;</a></span>__setup_from_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__setup_from_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Define os dados do problema com base nas informações fornecidas.

    @param data Um dicionário contendo os seguintes elementos:
        - `lp_variables`: Lista com os nomes das variáveis de decisão,
        - `constraint_matrix`: Matriz de restrições (A),
        - `is_maximization`: Booleano que indica se o problema é de maximização,
        - `objective_function`: Vetor da função objetivo (c),
        - `restrictions_vector`: Vetor das restrições (b),
        - `symbols`: Lista de símbolos das restrições (≤, =, ≥).

    @details
    Esse método inicializa os dados principais do problema (variáveis, matriz de restrições, função objetivo, etc.)
    com base no dicionário resultante do parser de arquivo passado anteriormente.

    @warning Só deve ser usado após ter dados carregados no Parser
</pre> 
</div>
</div>
<a id="abb45958124682c0418daac73a5759e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb45958124682c0418daac73a5759e1c">&#9670;&nbsp;</a></span>__show_process_results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__show_process_results </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Exibe ou salva os resultados finais do problema.

    @param show_steps Indica se os detalhes devem ser incluídos no LaTeX.

    @details
    Baseado no status final do problema (solução ótima, degenerada, inviável ou ilimitado),
    este método também apresentará a solução numérica do problema
    de forma detalhada ou simplificada a depender do lugar onde este estiver escrevendo.
</pre> 
</div>
</div>
<a id="a76d733abace2ffd0b747692d59d3439f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d733abace2ffd0b747692d59d3439f">&#9670;&nbsp;</a></span>__solve_phase_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int Solver.RevisedSimplex.__solve_phase_one </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Resolve a Fase 1 do Simplex Revisado para remover as variáveis artificiais acrescentadas na padronização do problema.

    @param show_steps Exibe os detalhes da resolução passo a passo no LaTeX, se `True`.
    @return Retorna:
        - `0` se a Fase 1 for concluída com sucesso,
        - `-1` se a fase 1 não foi necessária, ou não pode ser concluida.

    @details
    Na Fase 1, o algoritmo tenta remover as variáveis artificiais da base procurando por uma solução factível
    e em seguida, verificar se o problema é viável.
    Caso ele não seja, o status do problema é atualizado para "inviável" ou para "ilimitado".
</pre> 
</div>
</div>
<a id="a8c9ab746ff251a96092aa6e62dc93146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9ab746ff251a96092aa6e62dc93146">&#9670;&nbsp;</a></span>__solve_phase_two()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__solve_phase_two </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_phase_one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Resolve a Fase 2 do Simplex Revisado para encontrar a solução ótima.

    @param from_phase_one Indica se a Fase 1 ocorreu anteriormente, influenciando na escolha da base.
    @param show_steps Exibe os detalhes das operações no LaTeX, se `True`.

    @details
    Durante a Fase 2, o método busca encontrar a solução ótima do problema, para além de
    durante o processo, verificar a inviabilidade, ou ilimitabilidade do problema.
</pre> 
</div>
</div>
<a id="a274b595d119eb9e7b40b7fcd49a3e7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274b595d119eb9e7b40b7fcd49a3e7a3">&#9670;&nbsp;</a></span>__solver_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int Solver.RevisedSimplex.__solver_loop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray[np.float64]&#160;</td>
          <td class="paramname"><em>basic_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[int]&#160;</td>
          <td class="paramname"><em>basic_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[int]&#160;</td>
          <td class="paramname"><em>non_basic_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.array(np.float64)&#160;</td>
          <td class="paramname"><em>profit_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray[np.float64]&#160;</td>
          <td class="paramname"><em>restrictions_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_phase_one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">@brief Realiza as iterações do Simplex até alcançar a solução ótima, ou até que as variáveis artificiais
        sejam removidas para o caso da Fase 1.

@param basic_matrix Matriz básica (B) na iteração atual.
@param basic_indexes Lista com os índices das variáveis básicas. (Com respeito a lista de todas as variáveis do problema)
@param non_basic_indexes Lista com os índices das variáveis não básicas. (Com respeito a lista de todas as variáveis do problema)
@param profit_vector Vetor de lucros (c).
@param restrictions_vector Vetor de restrições (b).
@param is_phase_one Define se a iteração faz parte da Fase 1.
@param show_steps Exibe os passos em um arquivo LaTeX, se `True`.

@return Indica o estado final do algoritmo:
    - `0`: Solução ótima alcançada,
    - `-1`: Problema ilimitado,
    - `-3`: Iteração máxima excedida.

@details
Este método realiza os cálculos centrais do algoritmo Simplex, incluindo:
1. Solução básica (x_b),
2. Cálculo dos custos reduzidos,
3. Seleção de pivôs (tanto de entrada quanto de saída),
4. Atualizações da base e das matrizes com base nos pivôs selecionados.

@note Este método é uma implementação genérica para ambas as fases do Simplex, sendo aproveitado pro ambas.
A ideia principal é garantir que, ao analisar o código, seja notado que a diferença entre cada fase,
é apenas com respeito a condição de parada e condição inicial do problema, mas o intermédio é o mesmo.

Esse seria o equivalente ao chamado "Coração do simplex" de acordo com os autores do SciPy.
</pre> 
</div>
</div>
<a id="aba69122232d92b4ed294447f156799ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba69122232d92b4ed294447f156799ac">&#9670;&nbsp;</a></span>__standardize_problem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__standardize_problem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">@brief Padroniza o problema para o formato compatível com o método Simplex.

@param show_steps Exibe o detalhamento das alterações no LaTeX, se True.

@details
- Adiciona variáveis de folga para equações '≤',
- Adiciona variáveis artificiais para equações '=' ou '≥',
- Atualiza a matriz de restrição (A) e os vetores de variáveis.
O algoritmo realiza essas alterações para transformar o problema em sua forma padrão.

@note Este método é chamado internamente antes de resolver o problema para colocá-lo na forma padrão.
</pre> 
</div>
</div>
<a id="a85b81203e609fc44217d9dfdd257d8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b81203e609fc44217d9dfdd257d8b4">&#9670;&nbsp;</a></span>__update_variable_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> (int, int) Solver.RevisedSimplex.__update_variable_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basic_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str]&#160;</td>
          <td class="paramname"><em>variables_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in_index_non_basic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_index_basic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Atualiza os valores das variáveis básicas e não básicas após pivotar.

    @param basic_indexes Índices das variáveis que compõem a matriz básica (B).
    @param variables_list Lista geral com os nomes das variáveis do problema.
            # Provavelmente este aqui não precisaria ser passado através da função...

    @param x_b Vetor de soluções básicas atuais.
    @param y Vetor direção para o cálculo da variável pivotada.
    @param out_index Índice da variável básica com respeito a lista de variáveis básicas, e não de variáveis globais.
    @param in_index_non_basic Índice da variável não básica que entrará na base.
    @param out_index_basic Índice da variável básica que sairá da base.

    @return Uma tupla `(in_index_non_basic, out_index_basic)` após trocar os valores.
    (Utilizado posteriormente para atualizar as posições da matriz básica de forma mais eficiente)

    @details
    Atualiza os valores das variáveis e realiza a troca entre variáveis básicas e não
    básicas, conforme indicado pelos pivôs calculados em iterações anteriores.
</pre> 
</div>
</div>
<a id="a37e379031ec684055348de42faa107bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e379031ec684055348de42faa107bf">&#9670;&nbsp;</a></span>__write_current_problem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def Solver.RevisedSimplex.__write_current_problem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Escreve no documento em Latex, o problema formatado.

    @details
    O método reconstrói o problema através dos dados fornecidos pelo Parser.
    de forma a adaptar sua estrutura para uma forma mais facilmente visível.
    E de forma a destacar as mudanças antes da padronização e após padronização.
</pre> 
</div>
</div>
<a id="add1c93bdffb634a053090303a147fee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1c93bdffb634a053090303a147fee9">&#9670;&nbsp;</a></span>_load_problem_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex._load_problem_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">@brief Carrega os dados do problema de um arquivo.

@param file Caminho para o arquivo contendo os dados do problema linear.

@details
Os dados são lidos e processados utilizando o `FileParser`. Após a leitura,
as informações são configuradas nos atributos da classe, como variáveis, matriz de restrição e função objetivo
por uma outra função auxiliar.
</pre> 
</div>
</div>
<a id="aa2911bc5e52dff2c455a2e721f883247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2911bc5e52dff2c455a2e721f883247">&#9670;&nbsp;</a></span>_setup_support_variables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex._setup_support_variables </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">    @brief Configura variáveis de suporte internas para o problema carregado.

    @details
    Esta função inicializa e define várias variáveis necessárias para resolver o problema:
    - `variable_values` para armazenar os valores das variáveis,
    - `slack_variables` e `artificial_variables` para rastrear as variáveis introduzidas na padronização,
    - `status` para indicar o estado atual do problema, e qual a condição da solução,
    - `degeneracy_points` para lidar com casos degenerados durante o Simplex e indicar em quais iterações eles aconteceram.

    @warning Deve ser chamado após o problema ter sido carregado, caso contrário, as variáveis dependentes do problema não serão configuradas corretamente.
</pre> 
</div>
</div>
<a id="ad7bb9e61fa0cb4695d850422334a55e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bb9e61fa0cb4695d850422334a55e2">&#9670;&nbsp;</a></span>get_solution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict Solver.RevisedSimplex.get_solution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    @brief Retorna a solução das variáveis do problema.

    @return Um dicionário onde as chaves são os nomes das variáveis e os valores
            correspondem à solução encontrada para cada uma delas.

    @details
    Esse método formata o resultado final do problema, associando os nomes das variáveis
    a seus valores obtidos na solução ótima ou degenerada de forma a facilitar
    sua representação.
</pre> 
</div>
</div>
<a id="ac18e8bb26b40d183a4414ebf4bceee72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18e8bb26b40d183a4414ebf4bceee72">&#9670;&nbsp;</a></span>reload_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.reload_problem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    @brief Recarrega os dados de um novo problema a partir de um arquivo.

    @param file O caminho para o arquivo contendo os dados do novo problema.

    @details
    Este método lê um novo problema do arquivo fornecido e redefine as variáveis configuradas
    para que o algoritmo possa ser executado novamente.

    @note
    Usado especialmente para quando queremos escrever várias soluções num mesmo arquivo.
</pre> 
</div>
</div>
<a id="a2fb9c8edf4106fac8345cee091361a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb9c8edf4106fac8345cee091361a79">&#9670;&nbsp;</a></span>set_next_exercise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def Solver.RevisedSimplex.set_next_exercise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">    @brief Configura o documento latex e o solver para resolver outro problema.

    @details Incrementa o contador de exercícios em 1, e adiciona uma quebra de linha ao
    documento LaTeX para separar cada exercício resolvido.
</pre> 
</div>
</div>
<a id="ad6ad34b6cb6a487c97cb3f69d69062da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ad34b6cb6a487c97cb3f69d69062da">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def Solver.RevisedSimplex.solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">@brief Resolve o problema de programação linear carregado.

@param show_steps Exibe os passos do algoritmo em LaTeX, se definido como True.

@details
Executa cada etapa do algoritmo do Simplex Revisado, de forma sequencial:
- Padroniza o problema com variáveis artificiais e de folga,
- Resolve a Fase 1 para remoção de variáveis artificiais,
- Resolve a Fase 2 para obter a solução ótima.

@note
A solução final ou mensagens de erro (problema inviável ou ilimitado) são impressas
ou registradas no arquivo gerado em LaTeX.
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Solver.py</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSolver.html">Solver</a></li><li class="navelem"><a class="el" href="classSolver_1_1RevisedSimplex.html">RevisedSimplex</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
