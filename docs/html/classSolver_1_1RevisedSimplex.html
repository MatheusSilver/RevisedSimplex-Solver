<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simplex Solver Simplificado: Solver.RevisedSimplex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simplex Solver Simplificado
   </div>
   <div id="projectbrief">Um projeto didático para resolver problemas de otimização linear com o método simplex revisado, gerando explicações detalhadas em LaTeX.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSolver_1_1RevisedSimplex.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSolver_1_1RevisedSimplex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Solver.RevisedSimplex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Solver.RevisedSimplex:</div>
<div class="dyncontent">
<div class="center"><img src="classSolver_1_1RevisedSimplex__inherit__graph.png" border="0" usemap="#aSolver_8RevisedSimplex_inherit__map" alt="Inheritance graph"/></div>
<map name="aSolver_8RevisedSimplex_inherit__map" id="aSolver_8RevisedSimplex_inherit__map">
<area shape="rect" title=" " alt="" coords="25,5,231,523"/>
<area shape="rect" href="classSolver_1_1RevisedSimplexWithoutFile.html" title=" " alt="" coords="5,571,251,721"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for Solver.RevisedSimplex:</div>
<div class="dyncontent">
<div class="center"><img src="classSolver_1_1RevisedSimplex__coll__graph.png" border="0" usemap="#aSolver_8RevisedSimplex_coll__map" alt="Collaboration graph"/></div>
<map name="aSolver_8RevisedSimplex_coll__map" id="aSolver_8RevisedSimplex_coll__map">
<area shape="rect" title=" " alt="" coords="5,5,212,523"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a79c7e4d746c2723a6f19c6e551f86950"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a79c7e4d746c2723a6f19c6e551f86950">__init__</a> (self, str file=&quot;&quot;, bool show_steps=False, LatexWriter latex_writer=None)</td></tr>
<tr class="memdesc:a79c7e4d746c2723a6f19c6e551f86950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construtor da classe <a class="el" href="classSolver_1_1RevisedSimplex.html">RevisedSimplex</a>.  <a href="classSolver_1_1RevisedSimplex.html#a79c7e4d746c2723a6f19c6e551f86950">More...</a><br /></td></tr>
<tr class="separator:a79c7e4d746c2723a6f19c6e551f86950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18e8bb26b40d183a4414ebf4bceee72"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ac18e8bb26b40d183a4414ebf4bceee72">reload_problem</a> (self, str file)</td></tr>
<tr class="memdesc:ac18e8bb26b40d183a4414ebf4bceee72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recarrega os dados de um novo problema a partir de um arquivo.  <a href="classSolver_1_1RevisedSimplex.html#ac18e8bb26b40d183a4414ebf4bceee72">More...</a><br /></td></tr>
<tr class="separator:ac18e8bb26b40d183a4414ebf4bceee72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af939ff365f4f869b280fc2681ce66d77"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#af939ff365f4f869b280fc2681ce66d77">solve</a> (self, bool show_steps=False)</td></tr>
<tr class="memdesc:af939ff365f4f869b280fc2681ce66d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve o problema de programação linear carregado.  <a href="classSolver_1_1RevisedSimplex.html#af939ff365f4f869b280fc2681ce66d77">More...</a><br /></td></tr>
<tr class="separator:af939ff365f4f869b280fc2681ce66d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bb9e61fa0cb4695d850422334a55e2"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ad7bb9e61fa0cb4695d850422334a55e2">get_solution</a> (self)</td></tr>
<tr class="memdesc:ad7bb9e61fa0cb4695d850422334a55e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna a solução das variáveis do problema.  <a href="classSolver_1_1RevisedSimplex.html#ad7bb9e61fa0cb4695d850422334a55e2">More...</a><br /></td></tr>
<tr class="separator:ad7bb9e61fa0cb4695d850422334a55e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d704033dded731888c0e3c6a5ef657e"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a4d704033dded731888c0e3c6a5ef657e">set_next_exercise</a> (self)</td></tr>
<tr class="memdesc:a4d704033dded731888c0e3c6a5ef657e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configura o documento latex e o solver para resolver outro problema.  <a href="classSolver_1_1RevisedSimplex.html#a4d704033dded731888c0e3c6a5ef657e">More...</a><br /></td></tr>
<tr class="separator:a4d704033dded731888c0e3c6a5ef657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a14d6b31f2c11c39bbfcc828c20b3dade"><td class="memItemLeft" align="right" valign="top"><a id="a14d6b31f2c11c39bbfcc828c20b3dade"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>should_close</b></td></tr>
<tr class="separator:a14d6b31f2c11c39bbfcc828c20b3dade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba56960fb59b4d97911e4d3bbbcbc1e7"><td class="memItemLeft" align="right" valign="top"><a id="aba56960fb59b4d97911e4d3bbbcbc1e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>latexWriter</b></td></tr>
<tr class="separator:aba56960fb59b4d97911e4d3bbbcbc1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bb83e183148fef8d997ea17a96355a"><td class="memItemLeft" align="right" valign="top"><a id="ab3bb83e183148fef8d997ea17a96355a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>variable_values</b></td></tr>
<tr class="separator:ab3bb83e183148fef8d997ea17a96355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23fb48d030b160c3e7563f7401336f2"><td class="memItemLeft" align="right" valign="top"><a id="ab23fb48d030b160c3e7563f7401336f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>slack_variables</b></td></tr>
<tr class="separator:ab23fb48d030b160c3e7563f7401336f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95374ec3be9980eaa362b4b1785dee99"><td class="memItemLeft" align="right" valign="top"><a id="a95374ec3be9980eaa362b4b1785dee99"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>artificial_variables</b></td></tr>
<tr class="separator:a95374ec3be9980eaa362b4b1785dee99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b4e92ec9686cf80f3400ed31fb1bc"><td class="memItemLeft" align="right" valign="top"><a id="a2f4b4e92ec9686cf80f3400ed31fb1bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>status</b></td></tr>
<tr class="separator:a2f4b4e92ec9686cf80f3400ed31fb1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09df57c1b59aeec97d290e9cb35e0137"><td class="memItemLeft" align="right" valign="top"><a id="a09df57c1b59aeec97d290e9cb35e0137"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>degeneracy_points</b></td></tr>
<tr class="separator:a09df57c1b59aeec97d290e9cb35e0137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06cc15e825311373d2a0bfae617b5c7"><td class="memItemLeft" align="right" valign="top"><a id="ad06cc15e825311373d2a0bfae617b5c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>current_interaction</b></td></tr>
<tr class="separator:ad06cc15e825311373d2a0bfae617b5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08537c4cecd1083a0cae38bae3454ab"><td class="memItemLeft" align="right" valign="top"><a id="ad08537c4cecd1083a0cae38bae3454ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>variables</b></td></tr>
<tr class="separator:ad08537c4cecd1083a0cae38bae3454ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad836933e77c7f25a7356d065b7ffcbb7"><td class="memItemLeft" align="right" valign="top"><a id="ad836933e77c7f25a7356d065b7ffcbb7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>constraint_matrix</b></td></tr>
<tr class="separator:ad836933e77c7f25a7356d065b7ffcbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905ab3baa0c2b7efac22aed3964665bc"><td class="memItemLeft" align="right" valign="top"><a id="a905ab3baa0c2b7efac22aed3964665bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>isMaximization</b></td></tr>
<tr class="separator:a905ab3baa0c2b7efac22aed3964665bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b09441acf4343165a558e2bfaa5b73"><td class="memItemLeft" align="right" valign="top"><a id="ae3b09441acf4343165a558e2bfaa5b73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>objective</b></td></tr>
<tr class="separator:ae3b09441acf4343165a558e2bfaa5b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0be177907ba917dcad31bc9d3b9e1f"><td class="memItemLeft" align="right" valign="top"><a id="a0b0be177907ba917dcad31bc9d3b9e1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>restrictions</b></td></tr>
<tr class="separator:a0b0be177907ba917dcad31bc9d3b9e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84081decc1b854c39e1f0d87c5c20b19"><td class="memItemLeft" align="right" valign="top"><a id="a84081decc1b854c39e1f0d87c5c20b19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>restriction_symbols</b></td></tr>
<tr class="separator:a84081decc1b854c39e1f0d87c5c20b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af990dd59207cb086143762f90000fee9"><td class="memItemLeft" align="right" valign="top"><a id="af990dd59207cb086143762f90000fee9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basis</b></td></tr>
<tr class="separator:af990dd59207cb086143762f90000fee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dae3b0f33b1ff9a186cd64167bdf40"><td class="memItemLeft" align="right" valign="top"><a id="ab6dae3b0f33b1ff9a186cd64167bdf40"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>non_basis</b></td></tr>
<tr class="separator:ab6dae3b0f33b1ff9a186cd64167bdf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:add1c93bdffb634a053090303a147fee9"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#add1c93bdffb634a053090303a147fee9">_load_problem_data</a> (self, str file)</td></tr>
<tr class="memdesc:add1c93bdffb634a053090303a147fee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carrega os dados do problema de um arquivo.  <a href="classSolver_1_1RevisedSimplex.html#add1c93bdffb634a053090303a147fee9">More...</a><br /></td></tr>
<tr class="separator:add1c93bdffb634a053090303a147fee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2911bc5e52dff2c455a2e721f883247"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#aa2911bc5e52dff2c455a2e721f883247">_setup_support_variables</a> (self)</td></tr>
<tr class="memdesc:aa2911bc5e52dff2c455a2e721f883247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configura variáveis de suporte internas para o problema carregado.  <a href="classSolver_1_1RevisedSimplex.html#aa2911bc5e52dff2c455a2e721f883247">More...</a><br /></td></tr>
<tr class="separator:aa2911bc5e52dff2c455a2e721f883247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a01e2b9ecdd4fac9bba86225351abc"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ae9a01e2b9ecdd4fac9bba86225351abc">__setup_from_data</a> (self, data)</td></tr>
<tr class="memdesc:ae9a01e2b9ecdd4fac9bba86225351abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define os dados do problema com base nas informações fornecidas.  <a href="classSolver_1_1RevisedSimplex.html#ae9a01e2b9ecdd4fac9bba86225351abc">More...</a><br /></td></tr>
<tr class="separator:ae9a01e2b9ecdd4fac9bba86225351abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8efd507c57fd1b6e1415a1104aaa7a"><td class="memItemLeft" align="right" valign="top">list[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#abf8efd507c57fd1b6e1415a1104aaa7a">__get_initial_artificial_basis</a> (self)</td></tr>
<tr class="memdesc:abf8efd507c57fd1b6e1415a1104aaa7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtém a base inicial com variáveis artificiais para a Fase 1.  <a href="classSolver_1_1RevisedSimplex.html#abf8efd507c57fd1b6e1415a1104aaa7a">More...</a><br /></td></tr>
<tr class="separator:abf8efd507c57fd1b6e1415a1104aaa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35d8f3aff5009b95a2a1b7722bec1cf"><td class="memItemLeft" align="right" valign="top">list[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ab35d8f3aff5009b95a2a1b7722bec1cf">__get_initial_artificial_non_basis</a> (self, list[str] initial_basis)</td></tr>
<tr class="memdesc:ab35d8f3aff5009b95a2a1b7722bec1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtém o conjunto de variáveis não basicas inicial complementando a base inicial.  <a href="classSolver_1_1RevisedSimplex.html#ab35d8f3aff5009b95a2a1b7722bec1cf">More...</a><br /></td></tr>
<tr class="separator:ab35d8f3aff5009b95a2a1b7722bec1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d733abace2ffd0b747692d59d3439f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a76d733abace2ffd0b747692d59d3439f">__solve_phase_one</a> (self, bool show_steps=False)</td></tr>
<tr class="memdesc:a76d733abace2ffd0b747692d59d3439f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve a Fase 1 do Simplex Revisado para remover as variáveis artificiais acrescentadas na padronização do problema.  <a href="classSolver_1_1RevisedSimplex.html#a76d733abace2ffd0b747692d59d3439f">More...</a><br /></td></tr>
<tr class="separator:a76d733abace2ffd0b747692d59d3439f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74656209d027685de91405351566ecf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a74656209d027685de91405351566ecf1">__check_infeasibility_phase_one</a> (self)</td></tr>
<tr class="memdesc:a74656209d027685de91405351566ecf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica a inviabilidade do problema durante a Fase 1.  <a href="classSolver_1_1RevisedSimplex.html#a74656209d027685de91405351566ecf1">More...</a><br /></td></tr>
<tr class="separator:a74656209d027685de91405351566ecf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9ab746ff251a96092aa6e62dc93146"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a8c9ab746ff251a96092aa6e62dc93146">__solve_phase_two</a> (self, bool from_phase_one, bool show_steps=False)</td></tr>
<tr class="memdesc:a8c9ab746ff251a96092aa6e62dc93146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve a Fase 2 do Simplex Revisado para encontrar a solução ótima.  <a href="classSolver_1_1RevisedSimplex.html#a8c9ab746ff251a96092aa6e62dc93146">More...</a><br /></td></tr>
<tr class="separator:a8c9ab746ff251a96092aa6e62dc93146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb45958124682c0418daac73a5759e1c"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#abb45958124682c0418daac73a5759e1c">__show_process_results</a> (self, bool show_steps=False)</td></tr>
<tr class="memdesc:abb45958124682c0418daac73a5759e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exibe ou salva os resultados finais do problema.  <a href="classSolver_1_1RevisedSimplex.html#abb45958124682c0418daac73a5759e1c">More...</a><br /></td></tr>
<tr class="separator:abb45958124682c0418daac73a5759e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8255320bbf4588211e601a539a8df0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#af8255320bbf4588211e601a539a8df0b">__check_infeasibility_phase_two</a> (self)</td></tr>
<tr class="memdesc:af8255320bbf4588211e601a539a8df0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica a inviabilidade do problema ao final da Fase 2.  <a href="classSolver_1_1RevisedSimplex.html#af8255320bbf4588211e601a539a8df0b">More...</a><br /></td></tr>
<tr class="separator:af8255320bbf4588211e601a539a8df0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274b595d119eb9e7b40b7fcd49a3e7a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a274b595d119eb9e7b40b7fcd49a3e7a3">__solver_loop</a> (self, np.ndarray[np.float64] basic_matrix, list[int] basic_indexes, list[int] non_basic_indexes, np.array(np.float64) profit_vector, np.ndarray[np.float64] restrictions_vector, bool is_phase_one, bool show_steps=False)</td></tr>
<tr class="memdesc:a274b595d119eb9e7b40b7fcd49a3e7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realiza as iterações do Simplex até alcançar a solução ótima, ou até que as variáveis artificiais sejam removidas para o caso da Fase 1.  <a href="classSolver_1_1RevisedSimplex.html#a274b595d119eb9e7b40b7fcd49a3e7a3">More...</a><br /></td></tr>
<tr class="separator:a274b595d119eb9e7b40b7fcd49a3e7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b81203e609fc44217d9dfdd257d8b4"><td class="memItemLeft" align="right" valign="top">(int, int)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a85b81203e609fc44217d9dfdd257d8b4">__update_variable_values</a> (self, basic_indexes, list[str] variables_list, x_b, y, out_index, in_index_non_basic, out_index_basic)</td></tr>
<tr class="memdesc:a85b81203e609fc44217d9dfdd257d8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atualiza os valores das variáveis básicas e não básicas após pivotar.  <a href="classSolver_1_1RevisedSimplex.html#a85b81203e609fc44217d9dfdd257d8b4">More...</a><br /></td></tr>
<tr class="separator:a85b81203e609fc44217d9dfdd257d8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd0709b313ccd11a32f285676ccd349"><td class="memItemLeft" align="right" valign="top">np.ndarray[np.float64]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#aedd0709b313ccd11a32f285676ccd349">__get_basic_matrix</a> (self, list[int] basic_indexes)</td></tr>
<tr class="memdesc:aedd0709b313ccd11a32f285676ccd349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtém a matriz das variáveis básicas usando os índices fornecidos.  <a href="classSolver_1_1RevisedSimplex.html#aedd0709b313ccd11a32f285676ccd349">More...</a><br /></td></tr>
<tr class="separator:aedd0709b313ccd11a32f285676ccd349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a7b88ca866dfbf3678b23d311f8add"><td class="memItemLeft" align="right" valign="top">list[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a92a7b88ca866dfbf3678b23d311f8add">__get_basic_indexes</a> (self)</td></tr>
<tr class="memdesc:a92a7b88ca866dfbf3678b23d311f8add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna os índices das variáveis básicas no problema.  <a href="classSolver_1_1RevisedSimplex.html#a92a7b88ca866dfbf3678b23d311f8add">More...</a><br /></td></tr>
<tr class="separator:a92a7b88ca866dfbf3678b23d311f8add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35c4803a7fa8e860414360ab58a4b18"><td class="memItemLeft" align="right" valign="top">list[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#ac35c4803a7fa8e860414360ab58a4b18">__get_non_basic_indexes</a> (self)</td></tr>
<tr class="memdesc:ac35c4803a7fa8e860414360ab58a4b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna os índices das variáveis não básicas no problema.  <a href="classSolver_1_1RevisedSimplex.html#ac35c4803a7fa8e860414360ab58a4b18">More...</a><br /></td></tr>
<tr class="separator:ac35c4803a7fa8e860414360ab58a4b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e95c4e43b310d7d20dbd9cb560ff13f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a7e95c4e43b310d7d20dbd9cb560ff13f">__get_negative_pivot</a> (self, np.ndarray[np.float64] reduced_costs, bool show_steps=False)</td></tr>
<tr class="memdesc:a7e95c4e43b310d7d20dbd9cb560ff13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determina ""o índice da variável que entrará na base (pivô de entrada).  <a href="classSolver_1_1RevisedSimplex.html#a7e95c4e43b310d7d20dbd9cb560ff13f">More...</a><br /></td></tr>
<tr class="separator:a7e95c4e43b310d7d20dbd9cb560ff13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a0cdf4862a5bbe98dd1f448bd707f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a93a0cdf4862a5bbe98dd1f448bd707f6">__get_positive_pivot</a> (self, np.array(np.float64) ratios, bool show_steps=False)</td></tr>
<tr class="memdesc:a93a0cdf4862a5bbe98dd1f448bd707f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determina o índice da variável que sairá da base (pivô de saída).  <a href="classSolver_1_1RevisedSimplex.html#a93a0cdf4862a5bbe98dd1f448bd707f6">More...</a><br /></td></tr>
<tr class="separator:a93a0cdf4862a5bbe98dd1f448bd707f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba69122232d92b4ed294447f156799ac"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#aba69122232d92b4ed294447f156799ac">__standardize_problem</a> (self, bool show_steps=False)</td></tr>
<tr class="memdesc:aba69122232d92b4ed294447f156799ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padroniza o problema para o formato compatível com o método Simplex.  <a href="classSolver_1_1RevisedSimplex.html#aba69122232d92b4ed294447f156799ac">More...</a><br /></td></tr>
<tr class="separator:aba69122232d92b4ed294447f156799ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0233c37d2b196bc7d77ccdfe588aa692"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a0233c37d2b196bc7d77ccdfe588aa692">__add_variable_to_matrix</a> (self, int line_to_add, int value)</td></tr>
<tr class="memdesc:a0233c37d2b196bc7d77ccdfe588aa692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adiciona uma nova variável (folga ou artificial) à matriz de restrições.  <a href="classSolver_1_1RevisedSimplex.html#a0233c37d2b196bc7d77ccdfe588aa692">More...</a><br /></td></tr>
<tr class="separator:a0233c37d2b196bc7d77ccdfe588aa692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde8769511e745db0e0d88170d382607"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#afde8769511e745db0e0d88170d382607">__add_variable_value_to_vector</a> (self, int line_to_add, int value)</td></tr>
<tr class="memdesc:afde8769511e745db0e0d88170d382607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adiciona o valor inicial de uma variável no vetor de valores das variáveis.  <a href="classSolver_1_1RevisedSimplex.html#afde8769511e745db0e0d88170d382607">More...</a><br /></td></tr>
<tr class="separator:afde8769511e745db0e0d88170d382607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1886dade4b3146a39e913956af0f05"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a7b1886dade4b3146a39e913956af0f05">__remove_artificial_variables</a> (self)</td></tr>
<tr class="memdesc:a7b1886dade4b3146a39e913956af0f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove as variáveis artificiais de todos os lugares do problema.  <a href="classSolver_1_1RevisedSimplex.html#a7b1886dade4b3146a39e913956af0f05">More...</a><br /></td></tr>
<tr class="separator:a7b1886dade4b3146a39e913956af0f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290b7c7b732387f9c427a47a84623fa0"><td class="memItemLeft" align="right" valign="top">list[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a290b7c7b732387f9c427a47a84623fa0">__get_variables_list</a> (self)</td></tr>
<tr class="memdesc:a290b7c7b732387f9c427a47a84623fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna a lista completa de variáveis no problema.  <a href="classSolver_1_1RevisedSimplex.html#a290b7c7b732387f9c427a47a84623fa0">More...</a><br /></td></tr>
<tr class="separator:a290b7c7b732387f9c427a47a84623fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769048999453ff3f9f2c2ea9c7aafa95"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a769048999453ff3f9f2c2ea9c7aafa95">__get_degenerate_string</a> (self)</td></tr>
<tr class="memdesc:a769048999453ff3f9f2c2ea9c7aafa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna uma string representando os pontos de degeneração ocorridos durante o processo separados por vírgula.  <a href="classSolver_1_1RevisedSimplex.html#a769048999453ff3f9f2c2ea9c7aafa95">More...</a><br /></td></tr>
<tr class="separator:a769048999453ff3f9f2c2ea9c7aafa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c401232d61ead557453cfe9d326304"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#a82c401232d61ead557453cfe9d326304">__print_current_exercise_status</a> (self, str status)</td></tr>
<tr class="memdesc:a82c401232d61ead557453cfe9d326304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifica o exercício e imprime o status da tela.  <a href="classSolver_1_1RevisedSimplex.html#a82c401232d61ead557453cfe9d326304">More...</a><br /></td></tr>
<tr class="separator:a82c401232d61ead557453cfe9d326304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad04f13295789a918da7d19f1579d130"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolver_1_1RevisedSimplex.html#aad04f13295789a918da7d19f1579d130">__write_current_problem</a> (self)</td></tr>
<tr class="memdesc:aad04f13295789a918da7d19f1579d130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escreve no documento em Latex, o problema formatado.  <a href="classSolver_1_1RevisedSimplex.html#aad04f13295789a918da7d19f1579d130">More...</a><br /></td></tr>
<tr class="separator:aad04f13295789a918da7d19f1579d130"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a40e1e8a4949eb8b04f184c6e31e70bf9"><td class="memItemLeft" align="right" valign="top"><a id="a40e1e8a4949eb8b04f184c6e31e70bf9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__exercise_number</b></td></tr>
<tr class="separator:a40e1e8a4949eb8b04f184c6e31e70bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a79c7e4d746c2723a6f19c6e551f86950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c7e4d746c2723a6f19c6e551f86950">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str &#160;</td>
          <td class="paramname"><em>file</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LatexWriter &#160;</td>
          <td class="paramname"><em>latex_writer</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construtor da classe <a class="el" href="classSolver_1_1RevisedSimplex.html">RevisedSimplex</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Nome do arquivo que contém os dados do problema de otimização linear. O padrão é uma string vazia (não utiliza arquivo). </td></tr>
    <tr><td class="paramname">show_steps</td><td>Indica se os passos intermediários do processo devem ser exibidos no LaTeX. </td></tr>
    <tr><td class="paramname">latex_writer</td><td>Instância de LatexWriter para gerar a saída em LaTeX. Opcional caso mais de um problema vá ser resolvido.</td></tr>
  </table>
  </dd>
</dl>
<p>Este construtor inicializa e configura a classe <a class="el" href="classSolver_1_1RevisedSimplex.html">RevisedSimplex</a>. Ele pode usar informações de um arquivo ou ser configurado manualmente através de sua classe filha para resolver problemas lineares passados através de uma matriz. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSolver_1_1RevisedSimplexWithoutFile.html">RevisedSimplexWithoutFile</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0233c37d2b196bc7d77ccdfe588aa692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0233c37d2b196bc7d77ccdfe588aa692">&#9670;&nbsp;</a></span>__add_variable_to_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__add_variable_to_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adiciona uma nova variável (folga ou artificial) à matriz de restrições. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_to_add</td><td>Índice da linha onde a variável deve ser adicionada. </td></tr>
    <tr><td class="paramname">value</td><td>O valor do multiplicador da variável na matriz (1 para folga ou -1 caso uma variável artificial esteja presente).</td></tr>
  </table>
  </dd>
</dl>
<p>Este método modifica a matriz de restrições (A) e ajusta o vetor de variáveis com a adição de novas colunas representando as variáveis introduzidas na padronização. </p><dl class="section note"><dt>Note</dt><dd>Este método é uma etapa necessária durante a padronização do problema. </dd></dl>

</div>
</div>
<a id="afde8769511e745db0e0d88170d382607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde8769511e745db0e0d88170d382607">&#9670;&nbsp;</a></span>__add_variable_value_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__add_variable_value_to_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adiciona o valor inicial de uma variável no vetor de valores das variáveis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_to_add</td><td>Linha de dada variável na matriz de restrições. </td></tr>
    <tr><td class="paramname">value</td><td>Multiplicador específico para a variável adicionada.</td></tr>
  </table>
  </dd>
</dl>
<p>Esse método ajusta os valores iniciais do vetor de variáveis com base na linha da matriz de restrições onde a nova variável foi introduzida.</p><ul>
<li>Se a variável é uma variável de folga mas com multiplicador (<code>-1</code>), o valor é automaticamente ajustado como <code>0</code>.</li>
<li>Caso contrário, usa o valor correspondente multiplicador no vetor de restrições (<code>1</code> geralmente). <dl class="section note"><dt>Note</dt><dd>Essa função é usada durante a inicialização das variáveis no problema padronizado. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a74656209d027685de91405351566ecf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74656209d027685de91405351566ecf1">&#9670;&nbsp;</a></span>__check_infeasibility_phase_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool Solver.RevisedSimplex.__check_infeasibility_phase_one </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifica a inviabilidade do problema durante a Fase 1. </p>
<dl class="section return"><dt>Returns</dt><dd>Retorna <code>True</code> se o problema for inviável, <code>False</code> caso contrário.</dd></dl>
<p>Esse método analisa se ainda há variáveis artificiais na base ou se algum valores dessas variáveis é diferente de 0. Se ambas as condições não forem satisfeitas, então o problema é viável e procedemos para a segunda fase. </p>

</div>
</div>
<a id="af8255320bbf4588211e601a539a8df0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8255320bbf4588211e601a539a8df0b">&#9670;&nbsp;</a></span>__check_infeasibility_phase_two()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool Solver.RevisedSimplex.__check_infeasibility_phase_two </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifica a inviabilidade do problema ao final da Fase 2. </p>
<dl class="section return"><dt>Returns</dt><dd>Retorna <code>True</code> se o problema for inviável, <code>False</code> caso contrário.</dd></dl>
<p>Esse método analisa se alguma variável possui valores negativos. Caso não possua, então o problema é viável e procedemos para a elucidação dos resultados. </p>

</div>
</div>
<a id="a92a7b88ca866dfbf3678b23d311f8add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a7b88ca866dfbf3678b23d311f8add">&#9670;&nbsp;</a></span>__get_basic_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[int] Solver.RevisedSimplex.__get_basic_indexes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retorna os índices das variáveis básicas no problema. </p>
<dl class="section return"><dt>Returns</dt><dd>Uma lista de índices das variáveis que compõem a base atual na lista de todas as variáveis do problema.</dd></dl>
<p>Esse método acessa a lista de variáveis básicas e retorna os respectivos índices consoante à lista concatenada de todas as variáveis do problema. </p><dl class="section note"><dt>Note</dt><dd>Utilizada na obtenção da matriz básica em cada iteração. </dd></dl>

</div>
</div>
<a id="aedd0709b313ccd11a32f285676ccd349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd0709b313ccd11a32f285676ccd349">&#9670;&nbsp;</a></span>__get_basic_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray[np.float64] Solver.RevisedSimplex.__get_basic_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[int]&#160;</td>
          <td class="paramname"><em>basic_indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtém a matriz das variáveis básicas usando os índices fornecidos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basic_indexes</td><td>Lista com os índices das variáveis básicas na matriz de restrições. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matriz de restrições apenas com as colunas correspondentes as variáveis básicas.</dd></dl>
<p>Usa os índices passados para selecionar as colunas da matriz de restrições que correspondem às variáveis atuais da base. </p>

</div>
</div>
<a id="a769048999453ff3f9f2c2ea9c7aafa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769048999453ff3f9f2c2ea9c7aafa95">&#9670;&nbsp;</a></span>__get_degenerate_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> str Solver.RevisedSimplex.__get_degenerate_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retorna uma string representando os pontos de degeneração ocorridos durante o processo separados por vírgula. </p>
<dl class="section return"><dt>Returns</dt><dd>Uma string contendo os índices das interações que resultaram em degeneração.</dd></dl>
<p>O método constrói uma string formatada que lista, por iteração, os pontos onde a degeneração foi identificada. Usado especialmente para apresentar os pontos onde diferentes escolhas poderiam ser tomadas para resolver o problema. </p><dl class="section warning"><dt>Warning</dt><dd>Deve ser usado somente após uma iteração com degeneração. </dd></dl>

</div>
</div>
<a id="abf8efd507c57fd1b6e1415a1104aaa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8efd507c57fd1b6e1415a1104aaa7a">&#9670;&nbsp;</a></span>__get_initial_artificial_basis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[str] Solver.RevisedSimplex.__get_initial_artificial_basis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtém a base inicial com variáveis artificiais para a Fase 1. </p>
<dl class="section return"><dt>Returns</dt><dd>Uma lista contendo a base factível inicial do problema para a Fase 1.</dd></dl>
<p>Durante a Fase 1, as variáveis artificiais são inseridas na base inicial para resolver o problema. Este método retorna a base inicial factível com base na matriz de restrições fornecida A ordem das linhas e adições de variável de folga e artificial é respeitada durante a construção. </p>

</div>
</div>
<a id="ab35d8f3aff5009b95a2a1b7722bec1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35d8f3aff5009b95a2a1b7722bec1cf">&#9670;&nbsp;</a></span>__get_initial_artificial_non_basis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[str] Solver.RevisedSimplex.__get_initial_artificial_non_basis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str]&#160;</td>
          <td class="paramname"><em>initial_basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtém o conjunto de variáveis não basicas inicial complementando a base inicial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_basis</td><td>Lista contendo o conjunto de variáveis básicas inicial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lista com as variáveis que não estão na base factível inicial.</dd></dl>
<p>As variáveis que não estão na base inicial factível são classificadas como não básicas no início do algoritmo. Esse método retorna essas variáveis com base nas variáveis básicas para ser usado em iterações posteriores. </p><dl class="section warning"><dt>Warning</dt><dd>Deve ser executado após obter a base inicial. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSolver_1_1RevisedSimplex.html#abf8efd507c57fd1b6e1415a1104aaa7a" title="Obtém a base inicial com variáveis artificiais para a Fase 1.">__get_initial_artificial_basis</a> </dd></dl>

</div>
</div>
<a id="a7e95c4e43b310d7d20dbd9cb560ff13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e95c4e43b310d7d20dbd9cb560ff13f">&#9670;&nbsp;</a></span>__get_negative_pivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int Solver.RevisedSimplex.__get_negative_pivot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray[np.float64]&#160;</td>
          <td class="paramname"><em>reduced_costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determina ""o índice da variável que entrará na base (pivô de entrada). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduced_costs</td><td>Um vetor contendo os custos reduzidos das variáveis não básicas. </td></tr>
    <tr><td class="paramname">show_steps</td><td>Booleano que indica se os detalhes do processo serão escritos no LaTeX. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna o índice da variável não básica com menor custo reduzido (menor valor negativo):<ul>
<li>Índice inteiro do pivô escolhido,</li>
<li><code>-1</code> se não houver valores negativos (indica que a solução é ótima).</li>
</ul>
</dd></dl>
<p>Identifica a variável que entrará na base ao procurar o menor valor negativo em <code>reduced_costs</code>. Este valor define a direção de melhoria para o custo da função objetivo.</p><ol type="1">
<li>Valores negativos em <code>reduced_costs</code> indicam possíveis melhorias no custo.</li>
<li>O pivô é selecionado com base no menor custo reduzido negativo.</li>
<li>Se houver múltiplos candidatos com o mesmo valor, o método detecta degeneração, e registra a iteração em que ocorreu."" </li>
</ol>

</div>
</div>
<a id="ac35c4803a7fa8e860414360ab58a4b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35c4803a7fa8e860414360ab58a4b18">&#9670;&nbsp;</a></span>__get_non_basic_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[int] Solver.RevisedSimplex.__get_non_basic_indexes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retorna os índices das variáveis não básicas no problema. </p>
<dl class="section return"><dt>Returns</dt><dd>Uma lista de índices das variáveis que não compõem a base atual na lista de todas as variáveis do problema.</dd></dl>
<p>Funciona de forma similar a <code>__get_basic_indexes</code>, mas acessa diretamente as variáveis classificadas como não básicas e retorna seus índices. </p><dl class="section note"><dt>Note</dt><dd>Utilizada no calculo dos custos reduzidos em cada iteração. </dd></dl>

</div>
</div>
<a id="a93a0cdf4862a5bbe98dd1f448bd707f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a0cdf4862a5bbe98dd1f448bd707f6">&#9670;&nbsp;</a></span>__get_positive_pivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int Solver.RevisedSimplex.__get_positive_pivot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.array(np.float64)&#160;</td>
          <td class="paramname"><em>ratios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determina o índice da variável que sairá da base (pivô de saída). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratios</td><td>Um vetor contendo os coeficientes das razões entre as variáveis básicas (<code>x_b</code>) e os valores correspondentes em <code>y</code>. </td></tr>
    <tr><td class="paramname">show_steps</td><td>Booleano que indica se os detalhes do método serão escritos no LaTeX. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna o índice da variável básica que será removida da base:<ul>
<li>Índice inteiro do pivô escolhido para sair,</li>
<li><code>-1</code> se não houver índices válidos (indica problema ilimitado).</li>
</ul>
</dd></dl>
<p>Este método calcula o pivô de saída seguindo o critério da razão mínima, onde as razões <code>x_b / y</code> são analisadas. Apenas valores positivos em <code>y</code> são considerados:</p><ol type="1">
<li>O menor valor da razão determina o pivô que sairá.</li>
<li>Em casos onde há múltiplos mínimos, a degeneração é identificada para que seja rastreada durante o processo. </li>
</ol>

</div>
</div>
<a id="a290b7c7b732387f9c427a47a84623fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290b7c7b732387f9c427a47a84623fa0">&#9670;&nbsp;</a></span>__get_variables_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[str] Solver.RevisedSimplex.__get_variables_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retorna a lista completa de variáveis no problema. </p>
<dl class="section return"><dt>Returns</dt><dd>Uma lista contendo os nomes das variáveis originais, de folga e artificiais, nesta exata ordem de concatenação. </dd></dl>

</div>
</div>
<a id="a82c401232d61ead557453cfe9d326304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c401232d61ead557453cfe9d326304">&#9670;&nbsp;</a></span>__print_current_exercise_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__print_current_exercise_status </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifica o exercício e imprime o status da tela. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>identificador do erro ou da conclusão obtida durante a execução do algoritmo.</td></tr>
  </table>
  </dd>
</dl>
<p>Imprime de forma simplificada o identificador do exercício atual, e faz um leve detalhamento do seu status atual. </p>

</div>
</div>
<a id="a7b1886dade4b3146a39e913956af0f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1886dade4b3146a39e913956af0f05">&#9670;&nbsp;</a></span>__remove_artificial_variables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__remove_artificial_variables </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove as variáveis artificiais de todos os lugares do problema. </p>
<p>Este método só é executado após a conclusão bem sucedida da Fase 1, garantindo que as variáveis artificiais não sejam consideradas durante a Fase 2 para além de facilitar a visualização e elucidação da Fase 2 como seria feito manualmente. </p><dl class="section note"><dt>Note</dt><dd>Deve ser chamado APENAS após a finalização da Fase 1 bem sucedida da Fase 1. </dd></dl>

</div>
</div>
<a id="ae9a01e2b9ecdd4fac9bba86225351abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a01e2b9ecdd4fac9bba86225351abc">&#9670;&nbsp;</a></span>__setup_from_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__setup_from_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define os dados do problema com base nas informações fornecidas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Um dicionário contendo os seguintes elementos:<ul>
<li><code>lp_variables</code>: Lista com os nomes das variáveis de decisão,</li>
<li><code>constraint_matrix</code>: Matriz de restrições (A),</li>
<li><code>is_maximization</code>: Booleano que indica se o problema é de maximização,</li>
<li><code>objective_function</code>: Vetor da função objetivo (c),</li>
<li><code>restrictions_vector</code>: Vetor das restrições (b),</li>
<li><code>symbols</code>: Lista de símbolos das restrições (≤, =, ≥).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Esse método inicializa os dados principais do problema (variáveis, matriz de restrições, função objetivo, etc.) com base no dicionário resultante do parser de arquivo passado anteriormente. </p><dl class="section warning"><dt>Warning</dt><dd>Só deve ser usado após ter dados carregados pelo FileParser </dd></dl>

</div>
</div>
<a id="abb45958124682c0418daac73a5759e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb45958124682c0418daac73a5759e1c">&#9670;&nbsp;</a></span>__show_process_results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__show_process_results </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exibe ou salva os resultados finais do problema. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">show_steps</td><td>Indica se os detalhes devem ser incluídos no LaTeX.</td></tr>
  </table>
  </dd>
</dl>
<p>Baseado no status final do problema (solução ótima, degenerada, inviável ou ilimitado), este método também apresentará a solução numérica do problema de forma detalhada ou simplificada a depender do lugar onde este estiver escrevendo. </p>

</div>
</div>
<a id="a76d733abace2ffd0b747692d59d3439f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d733abace2ffd0b747692d59d3439f">&#9670;&nbsp;</a></span>__solve_phase_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int Solver.RevisedSimplex.__solve_phase_one </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve a Fase 1 do Simplex Revisado para remover as variáveis artificiais acrescentadas na padronização do problema. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">show_steps</td><td>Exibe os detalhes da resolução passo a passo no LaTeX, se <code>True</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna:<ul>
<li><code>0</code> se a Fase 1 for concluída com sucesso,</li>
<li><code>-1</code> se a fase 1 não foi necessária, ou não pode ser concluida.</li>
</ul>
</dd></dl>
<p>Na Fase 1, o algoritmo tenta remover as variáveis artificiais da base procurando por uma solução factível e em seguida, verificar se o problema é viável. Caso ele não seja, o status do problema é atualizado para "inviável" ou para "ilimitado". </p>

</div>
</div>
<a id="a8c9ab746ff251a96092aa6e62dc93146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9ab746ff251a96092aa6e62dc93146">&#9670;&nbsp;</a></span>__solve_phase_two()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__solve_phase_two </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_phase_one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve a Fase 2 do Simplex Revisado para encontrar a solução ótima. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_phase_one</td><td>Indica se a Fase 1 ocorreu anteriormente, influenciando na escolha da base. </td></tr>
    <tr><td class="paramname">show_steps</td><td>Exibe os detalhes das operações no LaTeX, se <code>True</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Durante a Fase 2, o método busca encontrar a solução ótima do problema, para além de durante o processo, verificar a inviabilidade, ou ilimitabilidade do problema. </p>

</div>
</div>
<a id="a274b595d119eb9e7b40b7fcd49a3e7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274b595d119eb9e7b40b7fcd49a3e7a3">&#9670;&nbsp;</a></span>__solver_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int Solver.RevisedSimplex.__solver_loop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray[np.float64]&#160;</td>
          <td class="paramname"><em>basic_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[int]&#160;</td>
          <td class="paramname"><em>basic_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[int]&#160;</td>
          <td class="paramname"><em>non_basic_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.array(np.float64)&#160;</td>
          <td class="paramname"><em>profit_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray[np.float64]&#160;</td>
          <td class="paramname"><em>restrictions_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_phase_one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Realiza as iterações do Simplex até alcançar a solução ótima, ou até que as variáveis artificiais sejam removidas para o caso da Fase 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basic_matrix</td><td>Matriz básica (B) na iteração atual. </td></tr>
    <tr><td class="paramname">basic_indexes</td><td>Lista com os índices das variáveis básicas. (Com respeito a lista de todas as variáveis do problema) </td></tr>
    <tr><td class="paramname">non_basic_indexes</td><td>Lista com os índices das variáveis não básicas. (Com respeito a lista de todas as variáveis do problema) </td></tr>
    <tr><td class="paramname">profit_vector</td><td>Vetor de lucros (c). </td></tr>
    <tr><td class="paramname">restrictions_vector</td><td>Vetor de restrições (b). </td></tr>
    <tr><td class="paramname">is_phase_one</td><td>Define se a iteração faz parte da Fase 1. </td></tr>
    <tr><td class="paramname">show_steps</td><td>Exibe os passos em um arquivo LaTeX, se <code>True</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indica o estado final do algoritmo:<ul>
<li><code>0</code>: Solução ótima alcançada,</li>
<li><code>-1</code>: Problema ilimitado,</li>
<li><code>-3</code>: Iteração máxima excedida.</li>
</ul>
</dd></dl>
<p>Este método realiza os cálculos centrais do algoritmo Simplex, incluindo:</p><ol type="1">
<li>Solução básica (x_b),</li>
<li>Cálculo dos custos reduzidos,</li>
<li>Seleção de pivôs (tanto de entrada quanto de saída),</li>
<li>Atualizações da base e das matrizes com base nos pivôs selecionados. <dl class="section note"><dt>Note</dt><dd>Este método é uma implementação genérica para ambas as fases do Simplex, sendo aproveitado pro ambas. A ideia principal é garantir que, ao analisar o código, seja notado que a diferença entre cada fase, é apenas com respeito a condição de parada e condição inicial do problema, mas o intermédio é o mesmo. Esse seria o equivalente ao chamado "Coração do simplex" de acordo com os autores do SciPy. </dd></dl>
</li>
</ol>

</div>
</div>
<a id="aba69122232d92b4ed294447f156799ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba69122232d92b4ed294447f156799ac">&#9670;&nbsp;</a></span>__standardize_problem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__standardize_problem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Padroniza o problema para o formato compatível com o método Simplex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">show_steps</td><td>Exibe o detalhamento das alterações no LaTeX, se True.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Adiciona variáveis de folga para equações '≤',</li>
<li>Adiciona variáveis artificiais para equações '=' ou '≥',</li>
<li>Atualiza a matriz de restrição (A) e os vetores de variáveis. O algoritmo realiza essas alterações para transformar o problema em sua forma padrão. <dl class="section note"><dt>Note</dt><dd>Este método é chamado internamente antes de resolver o problema para colocá-lo na forma padrão. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a85b81203e609fc44217d9dfdd257d8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b81203e609fc44217d9dfdd257d8b4">&#9670;&nbsp;</a></span>__update_variable_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> (int, int) Solver.RevisedSimplex.__update_variable_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basic_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[str]&#160;</td>
          <td class="paramname"><em>variables_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>in_index_non_basic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_index_basic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atualiza os valores das variáveis básicas e não básicas após pivotar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basic_indexes</td><td>Índices das variáveis que compõem a matriz básica (B). </td></tr>
    <tr><td class="paramname">variables_list</td><td>Lista geral com os nomes das variáveis do problema. </td></tr>
    <tr><td class="paramname">x_b</td><td>Vetor de soluções básicas atuais. </td></tr>
    <tr><td class="paramname">y</td><td>Vetor direção para o cálculo da variável pivotada. </td></tr>
    <tr><td class="paramname">out_index</td><td>Índice da variável básica com respeito a lista de variáveis básicas, e não de variáveis globais. </td></tr>
    <tr><td class="paramname">in_index_non_basic</td><td>Índice da variável não básica que entrará na base. </td></tr>
    <tr><td class="paramname">out_index_basic</td><td>Índice da variável básica que sairá da base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Uma tupla <code>(in_index_non_basic, out_index_basic)</code> após trocar os valores. (Utilizado posteriormente para atualizar as posições da matriz básica de forma mais eficiente)</dd></dl>
<p>Atualiza os valores das variáveis e realiza a troca entre variáveis básicas e não básicas, conforme indicado pelos pivôs calculados em iterações anteriores. </p>

</div>
</div>
<a id="aad04f13295789a918da7d19f1579d130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad04f13295789a918da7d19f1579d130">&#9670;&nbsp;</a></span>__write_current_problem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.__write_current_problem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Escreve no documento em Latex, o problema formatado. </p>
<p>O método reconstrói o problema através dos dados fornecidos pelo Parser. de forma a adaptar sua estrutura para uma forma mais facilmente visível. E de forma a destacar as mudanças antes da padronização e após padronização. </p>

</div>
</div>
<a id="add1c93bdffb634a053090303a147fee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1c93bdffb634a053090303a147fee9">&#9670;&nbsp;</a></span>_load_problem_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex._load_problem_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Carrega os dados do problema de um arquivo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Caminho para o arquivo contendo os dados do problema linear.</td></tr>
  </table>
  </dd>
</dl>
<p>Os dados são lidos e processados utilizando o <code>FileParser</code>. Após a leitura, as informações são configuradas nos atributos da classe, como variáveis, matriz de restrição e função objetivo por uma outra função auxiliar. </p>

</div>
</div>
<a id="aa2911bc5e52dff2c455a2e721f883247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2911bc5e52dff2c455a2e721f883247">&#9670;&nbsp;</a></span>_setup_support_variables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex._setup_support_variables </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configura variáveis de suporte internas para o problema carregado. </p>
<p>Esta função inicializa e define várias variáveis necessárias para resolver o problema:</p><ul>
<li><code>variable_values</code> para armazenar os valores das variáveis,</li>
<li><code>slack_variables</code> e <code>artificial_variables</code> para rastrear as variáveis introduzidas na padronização,</li>
<li><code>status</code> para indicar o estado atual do problema, e qual a condição da solução,</li>
<li><code>degeneracy_points</code> para lidar com casos degenerados durante o Simplex e indicar em quais iterações eles aconteceram. <dl class="section warning"><dt>Warning</dt><dd>Deve ser chamado após o problema ter sido carregado, caso contrário, as variáveis dependentes do problema não serão configuradas corretamente. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ad7bb9e61fa0cb4695d850422334a55e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bb9e61fa0cb4695d850422334a55e2">&#9670;&nbsp;</a></span>get_solution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> dict Solver.RevisedSimplex.get_solution </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retorna a solução das variáveis do problema. </p>
<dl class="section return"><dt>Returns</dt><dd>Um dicionário onde as chaves são os nomes das variáveis e os valores correspondem à solução encontrada para cada uma delas.</dd></dl>
<p>Esse método formata o resultado final do problema, associando os nomes das variáveis a seus valores obtidos na solução ótima ou degenerada de forma a facilitar sua representação. </p>

</div>
</div>
<a id="ac18e8bb26b40d183a4414ebf4bceee72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18e8bb26b40d183a4414ebf4bceee72">&#9670;&nbsp;</a></span>reload_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.reload_problem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recarrega os dados de um novo problema a partir de um arquivo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>O caminho para o arquivo contendo os dados do novo problema.</td></tr>
  </table>
  </dd>
</dl>
<p>Este método lê um novo problema do arquivo fornecido e redefine as variáveis configuradas para que o algoritmo possa ser executado novamente. </p><dl class="section note"><dt>Note</dt><dd>Usado especialmente para quando queremos escrever várias soluções num mesmo arquivo. </dd></dl>

</div>
</div>
<a id="a4d704033dded731888c0e3c6a5ef657e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d704033dded731888c0e3c6a5ef657e">&#9670;&nbsp;</a></span>set_next_exercise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.set_next_exercise </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configura o documento latex e o solver para resolver outro problema. </p>
<p>Incrementa o contador de exercícios em 1, e adiciona uma quebra de linha ao documento LaTeX para separar cada exercício resolvido. </p>

</div>
</div>
<a id="af939ff365f4f869b280fc2681ce66d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af939ff365f4f869b280fc2681ce66d77">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None Solver.RevisedSimplex.solve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>show_steps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve o problema de programação linear carregado. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">show_steps</td><td>Exibe os passos do algoritmo em LaTeX, se definido como True.</td></tr>
  </table>
  </dd>
</dl>
<p>Executa cada etapa do algoritmo do Simplex Revisado, de forma sequencial:</p><ul>
<li>Padroniza o problema com variáveis artificiais e de folga,</li>
<li>Resolve a Fase 1 para remoção de variáveis artificiais,</li>
<li>Resolve a Fase 2 para obter a solução ótima. <dl class="section note"><dt>Note</dt><dd>A solução final ou mensagens de erro (problema inviável ou ilimitado) são impressas ou registradas no arquivo gerado em LaTeX. </dd></dl>
</li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Solver_8py.html">Solver.py</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Solver</b></li><li class="navelem"><a class="el" href="classSolver_1_1RevisedSimplex.html">RevisedSimplex</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
